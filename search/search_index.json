{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Version Control Manager","text":"<p>Welcome to the documentation for the Version Control Manager project.</p> <p>This site includes:</p> <ul> <li>Source Code \u2014 Documentation generated directly from the <code>src/</code> package.</li> <li>Test(s) \u2014 Documentation generated directly from the <code>tests/</code> suite.</li> </ul>"},{"location":"src/","title":"Source Code","text":""},{"location":"src/#src.vcm.InvalidTagCreation","title":"<code>InvalidTagCreation</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception raised when attempting to create an invalid Git tag.</p> <p>This exception is used to prevent the creation of tags that would violate the versioning rules enforced by the VersionControlManager class.</p> Source code in <code>src/exceptions.py</code> <pre><code>class InvalidTagCreation(Exception):\n    \"\"\"Custom exception raised when attempting to create an invalid Git tag.\n\n    This exception is used to prevent the creation of tags that would violate\n    the versioning rules enforced by the VersionControlManager class.\n    \"\"\"\n    def __init__(self, message=\"Do not try to create an INVALID TAG!\"):\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager","title":"<code>VersionControlManager</code>","text":"<p>A manager class for handling Git tags with semantic versioning.</p> <p>This class provides functionality to create, manage, and increment Git tags following semantic versioning patterns. It supports development, release candidate, patch, and production tags with proper validation and incrementing logic.</p> <p>Attributes:</p> Name Type Description <code>repo</code> <code>Repo</code> <p>The GitPython repository object for the managed repository.</p> Source code in <code>src/vcm.py</code> <pre><code>class VersionControlManager:\n    \"\"\"A manager class for handling Git tags with semantic versioning.\n\n    This class provides functionality to create, manage, and increment Git tags\n    following semantic versioning patterns. It supports development, release candidate,\n    patch, and production tags with proper validation and incrementing logic.\n\n    Attributes:\n        repo (Repo): The GitPython repository object for the managed repository.\n    \"\"\"\n    def __init__(self, repo_path: str):\n        \"\"\"Initialize the VersionControlManager with a repository path.\n\n        If the repository doesn't exist at the given path, it will be created\n        and initialized as a new Git repository.\n\n        Args:\n            repo_path (str): The file system path to the Git repository.\n        \"\"\"\n        if not os.path.isdir(repo_path):\n            os.mkdir(repo_path)\n            self.repo = Repo.init(repo_path)\n        else:\n            self.repo = Repo(repo_path)\n\n\n    @staticmethod\n    def get_init_rc_tag(tag: str):\n        \"\"\"Generate an initial release candidate tag from a prerelease tag.\n\n        Takes a prerelease tag (e.g., \"1.2.3-dev.4\") and converts it to\n        an initial release candidate tag (e.g., \"1.2.3-rc.1\").\n\n        Args:\n            tag (str): A prerelease tag in the format \"X.Y.Z-prerelease.N\"\n\n        Returns:\n            str: The corresponding initial RC tag in format \"X.Y.Z-rc.1\"\n\n        Raises:\n            ValueError: If the tag doesn't match the expected prerelease pattern.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-([a-z]+)\\.(\\d+)$\"\n        if not re.fullmatch(pattern, tag):\n            raise ValueError\n\n        current_tag = semver.VersionInfo.parse(tag)\n        return f\"{current_tag.major}.{current_tag.minor}.{current_tag.patch}-rc.1\"\n\n\n    def find_tag(self, tag: str):\n        \"\"\"Check if a specific tag exists in the repository.\n\n        Performs an exact match search for the given tag name in the repository's\n        tag collection.\n\n        Args:\n            tag (str): The exact tag name to search for.\n\n        Returns:\n            bool: True if the tag exists, False otherwise.\n        \"\"\"\n        pattern = r\"^\" + tag + r\"$\"\n        return any(re.search(pattern,t.name.strip()) for t in self.repo.tags)\n\n\n    def find_tag_with_pattern(self, pattern: str):\n        \"\"\"Find the highest semantic version tag matching a regex pattern.\n\n        Searches through all repository tags for those matching the given regex pattern,\n        then returns the highest version according to semantic versioning rules.\n\n        Args:\n            pattern (str): Regular expression pattern to match against tag names.\n\n        Returns:\n            str or None: The highest semantic version tag matching the pattern,\n                        or None if no matching tags are found.\n        \"\"\"\n        tags = [tag.name.strip() for tag in self.repo.tags if re.search(pattern, tag.name)]\n        sorted_tags = sorted(tags, key=semver.VersionInfo.parse, reverse=True)\n        return sorted_tags[0] if sorted_tags else None\n\n\n    def get_current_tag(self, prerelease_tag: str=\"dev\", production: bool= False):\n        \"\"\"Get the current highest tag for a specific type (prerelease or production).\n\n        Retrieves the highest semantic version tag of either production format (X.Y.Z)\n        or prerelease format (X.Y.Z-prerelease.N) based on the parameters.\n\n        Args:\n            prerelease_tag (str, optional): The prerelease identifier (e.g., \"dev\", \"rc\").\n                                          Defaults to \"dev\".\n            production (bool, optional): If True, searches for production tags (X.Y.Z format).\n                                       If False, searches for prerelease tags. Defaults to False.\n\n        Returns:\n            str or None: The highest matching tag, or None if no matching tags exist.\n        \"\"\"\n        if production:\n            dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n        else:\n            dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-\" + prerelease_tag + r\"\\.(\\d+)$\"\n\n        return self.find_tag_with_pattern(dev_pattern)\n\n\n    def increment_prerelease_tag(self, tag: str=None, prerelease_tag: str=\"dev\", major_bump: bool= False):\n        \"\"\"Create and increment a prerelease tag.\n\n        Creates a new prerelease tag by either incrementing an existing tag or starting\n        a new version sequence. Handles major/minor version bumps when transitioning\n        from one prerelease to another.\n\n        Args:\n            tag (str, optional): Base tag to increment from. If None, starts with \"0.1.0-dev.1\".\n            prerelease_tag (str, optional): The prerelease identifier. Defaults to \"dev\".\n            major_bump (bool, optional): If True, performs a major version bump instead of minor.\n                                       Defaults to False.\n\n        Returns:\n            str: The newly created prerelease tag.\n\n        Raises:\n            ValueError: If the provided tag doesn't match the expected prerelease pattern.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-([a-z]+)\\.(\\d+)$\"\n        if tag:\n            if not re.fullmatch(pattern,tag):\n                raise ValueError\n            if self.find_tag(self.get_init_rc_tag(tag)):\n                if major_bump:\n                    next_tag = f\"{semver.VersionInfo.parse(tag).bump_major()}-{prerelease_tag}.1\"\n                else:\n                    next_tag = f\"{semver.VersionInfo.parse(tag).bump_minor()}-{prerelease_tag}.1\"\n            else:\n                next_tag = semver.VersionInfo.parse(tag).bump_prerelease()\n        else:\n            next_tag = f\"0.1.0-{prerelease_tag}.1\"\n\n        self.repo.create_tag(next_tag)\n        return next_tag\n\n\n    def init_new_rc(self, prerelease_tag: str=\"dev\"):\n        \"\"\"Initialize a new release candidate from the current development tag.\n\n        Creates the first release candidate tag (X.Y.Z-rc.1) based on the highest\n        existing development tag. The RC tag points to the same commit as the dev tag.\n\n        Args:\n            prerelease_tag (str, optional): The development prerelease identifier.\n                                          Defaults to \"dev\".\n\n        Returns:\n            str or None: The newly created RC tag name, or None if no development\n                        tag exists to base the RC on.\n        \"\"\"\n        current_dev_tag = self.get_current_tag(prerelease_tag)\n        if current_dev_tag:\n            t = semver.VersionInfo.parse(current_dev_tag)\n            init_release_tag = f\"{t.major}.{t.minor}.{t.patch}-rc.1\"\n            self.repo.create_tag(\n                init_release_tag,\n                ref=self.repo.commit(current_dev_tag),\n                message=(\n                    f\"Release candidate version: {init_release_tag} \" \n                    f\"created from Development version: {current_dev_tag}\"\n                )\n            )\n            return init_release_tag\n\n        return None\n\n\n    def init_new_patch(self):\n        \"\"\"Initialize a new patch prerelease from the current production tag.\n\n        Creates the first patch prerelease tag (X.Y.Z-patch.1) based on the highest\n        existing production tag. The patch tag points to the same commit as the production tag.\n\n        Returns:\n            str or None: The newly created patch tag name, or None if no production\n                        tag exists to base the patch on.\n        \"\"\"\n        current_prod = self.get_current_tag(production=True)\n        if current_prod:\n            init_patch_tag = f\"{current_prod}-patch.1\"\n            self.repo.create_tag(\n                init_patch_tag,\n                ref=self.repo.commit(current_prod),\n                message=(\n                    f\"Patch version: {init_patch_tag} \" \n                    f\"created from Production version: {current_prod}\"\n                )\n            )\n            return init_patch_tag\n\n        return None\n\n\n    def get_current_rc_patch(self, tag: str, prerelease_tag: str=\"rc\"):\n        \"\"\"Get the current highest RC or patch tag for a given base version.\n\n        Finds the highest prerelease tag (rc or patch) that corresponds to the given\n        base production version tag.\n\n        Args:\n            tag (str): Base production version tag in format \"X.Y.Z\".\n            prerelease_tag (str, optional): The prerelease type (\"rc\" or \"patch\").\n                                           Defaults to \"rc\".\n\n        Returns:\n            str or None: The highest matching prerelease tag, or None if none exist.\n\n        Raises:\n            ValueError: If the base tag doesn't match the production version pattern.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n        if not re.fullmatch(pattern, tag):\n            raise ValueError\n\n        rc_pattern = r\"^\" + tag + r\"-\" + prerelease_tag + r\"\\.(\\d+)$\"\n        return self.find_tag_with_pattern(rc_pattern)\n\n\n    def increment_rc_patch(self, tag: str, prerelease_tag: str=\"rc\"):\n        \"\"\"Increment a release candidate or patch prerelease tag.\n\n        Creates the next RC or patch prerelease tag for a given base version.\n        Includes validation to ensure proper versioning rules are followed.\n\n        Args:\n            tag (str): Base production version tag in format \"X.Y.Z\".\n            prerelease_tag (str, optional): The prerelease type (\"rc\" or \"patch\").\n                                           Defaults to \"rc\".\n\n        Returns:\n            str or None: The newly created incremented tag, or None if no base\n                        prerelease tag exists to increment.\n\n        Raises:\n            ValueError: If the base tag doesn't match the production version pattern.\n            InvalidTagCreation: If attempting to create an RC when production version\n                              exists, or attempting to create a patch when production\n                              version doesn't exist, or when a patch already exists\n                              in production.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n        if not re.fullmatch(pattern, tag):\n            raise ValueError\n\n        if  prerelease_tag == \"rc\" and self.find_tag(tag):\n            raise InvalidTagCreation(\n                \"Production version available. Cannot create Release Candidate version!\"\n            )\n        elif prerelease_tag == \"patch\" and not self.find_tag(tag):\n            raise InvalidTagCreation(\n                \"Production version not available. Cannot create Patch version!\"\n            )\n        elif prerelease_tag == \"rc\":\n            current_rc = self.get_current_rc_patch(tag)\n        elif prerelease_tag == \"patch\":\n            if self.find_tag(str(semver.VersionInfo.parse(tag).bump_patch())):\n                raise InvalidTagCreation(\n                    \"Cannot increment Patch pre-release version. Patch found in Production.\"\n                )\n            current_rc = self.get_current_rc_patch(tag, \"patch\")\n\n        if current_rc:\n            new_rc_tag = semver.VersionInfo.parse(current_rc).bump_prerelease()\n            self.repo.create_tag(new_rc_tag)\n            return new_rc_tag\n\n        return None\n\n\n    def create_prod_tag(self, tag: str):\n        \"\"\"Create a production tag from a release candidate or patch prerelease.\n\n        Converts an RC or patch prerelease tag into a production version tag.\n        For RC tags, creates the base version (X.Y.Z). For patch tags, creates\n        the next patch version (X.Y.Z+1).\n\n        Args:\n            tag (str): The RC or patch prerelease tag to promote to production.\n                      Format: \"X.Y.Z-rc.N\" or \"X.Y.Z-patch.N\".\n\n        Returns:\n            str: The newly created production tag.\n\n        Raises:\n            ValueError: If the tag doesn't match the expected RC or patch pattern.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-(rc|patch)\\.(\\d+)$\"\n        if not re.fullmatch(pattern, tag):\n            raise ValueError\n\n        if re.match(pattern,tag).group(4) == \"patch\":\n            new_prod_tag = semver.VersionInfo.parse(tag).bump_patch()\n        else:\n            t = semver.VersionInfo.parse(tag)\n            new_prod_tag = f\"{t.major}.{t.minor}.{t.patch}\"\n\n        self.repo.create_tag(\n            new_prod_tag,\n            ref=self.repo.commit(tag),\n            message=(\n                f\"Production version: {new_prod_tag} \"\n                f\"created from (Release Candidate | Patch) version: {tag}\"\n            )\n        )\n        return new_prod_tag\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.__init__","title":"<code>__init__(repo_path)</code>","text":"<p>Initialize the VersionControlManager with a repository path.</p> <p>If the repository doesn't exist at the given path, it will be created and initialized as a new Git repository.</p> <p>Parameters:</p> Name Type Description Default <code>repo_path</code> <code>str</code> <p>The file system path to the Git repository.</p> required Source code in <code>src/vcm.py</code> <pre><code>def __init__(self, repo_path: str):\n    \"\"\"Initialize the VersionControlManager with a repository path.\n\n    If the repository doesn't exist at the given path, it will be created\n    and initialized as a new Git repository.\n\n    Args:\n        repo_path (str): The file system path to the Git repository.\n    \"\"\"\n    if not os.path.isdir(repo_path):\n        os.mkdir(repo_path)\n        self.repo = Repo.init(repo_path)\n    else:\n        self.repo = Repo(repo_path)\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.create_prod_tag","title":"<code>create_prod_tag(tag)</code>","text":"<p>Create a production tag from a release candidate or patch prerelease.</p> <p>Converts an RC or patch prerelease tag into a production version tag. For RC tags, creates the base version (X.Y.Z). For patch tags, creates the next patch version (X.Y.Z+1).</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The RC or patch prerelease tag to promote to production.       Format: \"X.Y.Z-rc.N\" or \"X.Y.Z-patch.N\".</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The newly created production tag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag doesn't match the expected RC or patch pattern.</p> Source code in <code>src/vcm.py</code> <pre><code>def create_prod_tag(self, tag: str):\n    \"\"\"Create a production tag from a release candidate or patch prerelease.\n\n    Converts an RC or patch prerelease tag into a production version tag.\n    For RC tags, creates the base version (X.Y.Z). For patch tags, creates\n    the next patch version (X.Y.Z+1).\n\n    Args:\n        tag (str): The RC or patch prerelease tag to promote to production.\n                  Format: \"X.Y.Z-rc.N\" or \"X.Y.Z-patch.N\".\n\n    Returns:\n        str: The newly created production tag.\n\n    Raises:\n        ValueError: If the tag doesn't match the expected RC or patch pattern.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-(rc|patch)\\.(\\d+)$\"\n    if not re.fullmatch(pattern, tag):\n        raise ValueError\n\n    if re.match(pattern,tag).group(4) == \"patch\":\n        new_prod_tag = semver.VersionInfo.parse(tag).bump_patch()\n    else:\n        t = semver.VersionInfo.parse(tag)\n        new_prod_tag = f\"{t.major}.{t.minor}.{t.patch}\"\n\n    self.repo.create_tag(\n        new_prod_tag,\n        ref=self.repo.commit(tag),\n        message=(\n            f\"Production version: {new_prod_tag} \"\n            f\"created from (Release Candidate | Patch) version: {tag}\"\n        )\n    )\n    return new_prod_tag\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.find_tag","title":"<code>find_tag(tag)</code>","text":"<p>Check if a specific tag exists in the repository.</p> <p>Performs an exact match search for the given tag name in the repository's tag collection.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The exact tag name to search for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the tag exists, False otherwise.</p> Source code in <code>src/vcm.py</code> <pre><code>def find_tag(self, tag: str):\n    \"\"\"Check if a specific tag exists in the repository.\n\n    Performs an exact match search for the given tag name in the repository's\n    tag collection.\n\n    Args:\n        tag (str): The exact tag name to search for.\n\n    Returns:\n        bool: True if the tag exists, False otherwise.\n    \"\"\"\n    pattern = r\"^\" + tag + r\"$\"\n    return any(re.search(pattern,t.name.strip()) for t in self.repo.tags)\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.find_tag_with_pattern","title":"<code>find_tag_with_pattern(pattern)</code>","text":"<p>Find the highest semantic version tag matching a regex pattern.</p> <p>Searches through all repository tags for those matching the given regex pattern, then returns the highest version according to semantic versioning rules.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regular expression pattern to match against tag names.</p> required <p>Returns:</p> Type Description <p>str or None: The highest semantic version tag matching the pattern,         or None if no matching tags are found.</p> Source code in <code>src/vcm.py</code> <pre><code>def find_tag_with_pattern(self, pattern: str):\n    \"\"\"Find the highest semantic version tag matching a regex pattern.\n\n    Searches through all repository tags for those matching the given regex pattern,\n    then returns the highest version according to semantic versioning rules.\n\n    Args:\n        pattern (str): Regular expression pattern to match against tag names.\n\n    Returns:\n        str or None: The highest semantic version tag matching the pattern,\n                    or None if no matching tags are found.\n    \"\"\"\n    tags = [tag.name.strip() for tag in self.repo.tags if re.search(pattern, tag.name)]\n    sorted_tags = sorted(tags, key=semver.VersionInfo.parse, reverse=True)\n    return sorted_tags[0] if sorted_tags else None\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.get_current_rc_patch","title":"<code>get_current_rc_patch(tag, prerelease_tag='rc')</code>","text":"<p>Get the current highest RC or patch tag for a given base version.</p> <p>Finds the highest prerelease tag (rc or patch) that corresponds to the given base production version tag.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Base production version tag in format \"X.Y.Z\".</p> required <code>prerelease_tag</code> <code>str</code> <p>The prerelease type (\"rc\" or \"patch\").                            Defaults to \"rc\".</p> <code>'rc'</code> <p>Returns:</p> Type Description <p>str or None: The highest matching prerelease tag, or None if none exist.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the base tag doesn't match the production version pattern.</p> Source code in <code>src/vcm.py</code> <pre><code>def get_current_rc_patch(self, tag: str, prerelease_tag: str=\"rc\"):\n    \"\"\"Get the current highest RC or patch tag for a given base version.\n\n    Finds the highest prerelease tag (rc or patch) that corresponds to the given\n    base production version tag.\n\n    Args:\n        tag (str): Base production version tag in format \"X.Y.Z\".\n        prerelease_tag (str, optional): The prerelease type (\"rc\" or \"patch\").\n                                       Defaults to \"rc\".\n\n    Returns:\n        str or None: The highest matching prerelease tag, or None if none exist.\n\n    Raises:\n        ValueError: If the base tag doesn't match the production version pattern.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n    if not re.fullmatch(pattern, tag):\n        raise ValueError\n\n    rc_pattern = r\"^\" + tag + r\"-\" + prerelease_tag + r\"\\.(\\d+)$\"\n    return self.find_tag_with_pattern(rc_pattern)\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.get_current_tag","title":"<code>get_current_tag(prerelease_tag='dev', production=False)</code>","text":"<p>Get the current highest tag for a specific type (prerelease or production).</p> <p>Retrieves the highest semantic version tag of either production format (X.Y.Z) or prerelease format (X.Y.Z-prerelease.N) based on the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>prerelease_tag</code> <code>str</code> <p>The prerelease identifier (e.g., \"dev\", \"rc\").                           Defaults to \"dev\".</p> <code>'dev'</code> <code>production</code> <code>bool</code> <p>If True, searches for production tags (X.Y.Z format).                        If False, searches for prerelease tags. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>str or None: The highest matching tag, or None if no matching tags exist.</p> Source code in <code>src/vcm.py</code> <pre><code>def get_current_tag(self, prerelease_tag: str=\"dev\", production: bool= False):\n    \"\"\"Get the current highest tag for a specific type (prerelease or production).\n\n    Retrieves the highest semantic version tag of either production format (X.Y.Z)\n    or prerelease format (X.Y.Z-prerelease.N) based on the parameters.\n\n    Args:\n        prerelease_tag (str, optional): The prerelease identifier (e.g., \"dev\", \"rc\").\n                                      Defaults to \"dev\".\n        production (bool, optional): If True, searches for production tags (X.Y.Z format).\n                                   If False, searches for prerelease tags. Defaults to False.\n\n    Returns:\n        str or None: The highest matching tag, or None if no matching tags exist.\n    \"\"\"\n    if production:\n        dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n    else:\n        dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-\" + prerelease_tag + r\"\\.(\\d+)$\"\n\n    return self.find_tag_with_pattern(dev_pattern)\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.get_init_rc_tag","title":"<code>get_init_rc_tag(tag)</code>  <code>staticmethod</code>","text":"<p>Generate an initial release candidate tag from a prerelease tag.</p> <p>Takes a prerelease tag (e.g., \"1.2.3-dev.4\") and converts it to an initial release candidate tag (e.g., \"1.2.3-rc.1\").</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>A prerelease tag in the format \"X.Y.Z-prerelease.N\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The corresponding initial RC tag in format \"X.Y.Z-rc.1\"</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag doesn't match the expected prerelease pattern.</p> Source code in <code>src/vcm.py</code> <pre><code>@staticmethod\ndef get_init_rc_tag(tag: str):\n    \"\"\"Generate an initial release candidate tag from a prerelease tag.\n\n    Takes a prerelease tag (e.g., \"1.2.3-dev.4\") and converts it to\n    an initial release candidate tag (e.g., \"1.2.3-rc.1\").\n\n    Args:\n        tag (str): A prerelease tag in the format \"X.Y.Z-prerelease.N\"\n\n    Returns:\n        str: The corresponding initial RC tag in format \"X.Y.Z-rc.1\"\n\n    Raises:\n        ValueError: If the tag doesn't match the expected prerelease pattern.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-([a-z]+)\\.(\\d+)$\"\n    if not re.fullmatch(pattern, tag):\n        raise ValueError\n\n    current_tag = semver.VersionInfo.parse(tag)\n    return f\"{current_tag.major}.{current_tag.minor}.{current_tag.patch}-rc.1\"\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.increment_prerelease_tag","title":"<code>increment_prerelease_tag(tag=None, prerelease_tag='dev', major_bump=False)</code>","text":"<p>Create and increment a prerelease tag.</p> <p>Creates a new prerelease tag by either incrementing an existing tag or starting a new version sequence. Handles major/minor version bumps when transitioning from one prerelease to another.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Base tag to increment from. If None, starts with \"0.1.0-dev.1\".</p> <code>None</code> <code>prerelease_tag</code> <code>str</code> <p>The prerelease identifier. Defaults to \"dev\".</p> <code>'dev'</code> <code>major_bump</code> <code>bool</code> <p>If True, performs a major version bump instead of minor.                        Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The newly created prerelease tag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided tag doesn't match the expected prerelease pattern.</p> Source code in <code>src/vcm.py</code> <pre><code>def increment_prerelease_tag(self, tag: str=None, prerelease_tag: str=\"dev\", major_bump: bool= False):\n    \"\"\"Create and increment a prerelease tag.\n\n    Creates a new prerelease tag by either incrementing an existing tag or starting\n    a new version sequence. Handles major/minor version bumps when transitioning\n    from one prerelease to another.\n\n    Args:\n        tag (str, optional): Base tag to increment from. If None, starts with \"0.1.0-dev.1\".\n        prerelease_tag (str, optional): The prerelease identifier. Defaults to \"dev\".\n        major_bump (bool, optional): If True, performs a major version bump instead of minor.\n                                   Defaults to False.\n\n    Returns:\n        str: The newly created prerelease tag.\n\n    Raises:\n        ValueError: If the provided tag doesn't match the expected prerelease pattern.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-([a-z]+)\\.(\\d+)$\"\n    if tag:\n        if not re.fullmatch(pattern,tag):\n            raise ValueError\n        if self.find_tag(self.get_init_rc_tag(tag)):\n            if major_bump:\n                next_tag = f\"{semver.VersionInfo.parse(tag).bump_major()}-{prerelease_tag}.1\"\n            else:\n                next_tag = f\"{semver.VersionInfo.parse(tag).bump_minor()}-{prerelease_tag}.1\"\n        else:\n            next_tag = semver.VersionInfo.parse(tag).bump_prerelease()\n    else:\n        next_tag = f\"0.1.0-{prerelease_tag}.1\"\n\n    self.repo.create_tag(next_tag)\n    return next_tag\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.increment_rc_patch","title":"<code>increment_rc_patch(tag, prerelease_tag='rc')</code>","text":"<p>Increment a release candidate or patch prerelease tag.</p> <p>Creates the next RC or patch prerelease tag for a given base version. Includes validation to ensure proper versioning rules are followed.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Base production version tag in format \"X.Y.Z\".</p> required <code>prerelease_tag</code> <code>str</code> <p>The prerelease type (\"rc\" or \"patch\").                            Defaults to \"rc\".</p> <code>'rc'</code> <p>Returns:</p> Type Description <p>str or None: The newly created incremented tag, or None if no base         prerelease tag exists to increment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the base tag doesn't match the production version pattern.</p> <code>InvalidTagCreation</code> <p>If attempting to create an RC when production version               exists, or attempting to create a patch when production               version doesn't exist, or when a patch already exists               in production.</p> Source code in <code>src/vcm.py</code> <pre><code>def increment_rc_patch(self, tag: str, prerelease_tag: str=\"rc\"):\n    \"\"\"Increment a release candidate or patch prerelease tag.\n\n    Creates the next RC or patch prerelease tag for a given base version.\n    Includes validation to ensure proper versioning rules are followed.\n\n    Args:\n        tag (str): Base production version tag in format \"X.Y.Z\".\n        prerelease_tag (str, optional): The prerelease type (\"rc\" or \"patch\").\n                                       Defaults to \"rc\".\n\n    Returns:\n        str or None: The newly created incremented tag, or None if no base\n                    prerelease tag exists to increment.\n\n    Raises:\n        ValueError: If the base tag doesn't match the production version pattern.\n        InvalidTagCreation: If attempting to create an RC when production version\n                          exists, or attempting to create a patch when production\n                          version doesn't exist, or when a patch already exists\n                          in production.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n    if not re.fullmatch(pattern, tag):\n        raise ValueError\n\n    if  prerelease_tag == \"rc\" and self.find_tag(tag):\n        raise InvalidTagCreation(\n            \"Production version available. Cannot create Release Candidate version!\"\n        )\n    elif prerelease_tag == \"patch\" and not self.find_tag(tag):\n        raise InvalidTagCreation(\n            \"Production version not available. Cannot create Patch version!\"\n        )\n    elif prerelease_tag == \"rc\":\n        current_rc = self.get_current_rc_patch(tag)\n    elif prerelease_tag == \"patch\":\n        if self.find_tag(str(semver.VersionInfo.parse(tag).bump_patch())):\n            raise InvalidTagCreation(\n                \"Cannot increment Patch pre-release version. Patch found in Production.\"\n            )\n        current_rc = self.get_current_rc_patch(tag, \"patch\")\n\n    if current_rc:\n        new_rc_tag = semver.VersionInfo.parse(current_rc).bump_prerelease()\n        self.repo.create_tag(new_rc_tag)\n        return new_rc_tag\n\n    return None\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.init_new_patch","title":"<code>init_new_patch()</code>","text":"<p>Initialize a new patch prerelease from the current production tag.</p> <p>Creates the first patch prerelease tag (X.Y.Z-patch.1) based on the highest existing production tag. The patch tag points to the same commit as the production tag.</p> <p>Returns:</p> Type Description <p>str or None: The newly created patch tag name, or None if no production         tag exists to base the patch on.</p> Source code in <code>src/vcm.py</code> <pre><code>def init_new_patch(self):\n    \"\"\"Initialize a new patch prerelease from the current production tag.\n\n    Creates the first patch prerelease tag (X.Y.Z-patch.1) based on the highest\n    existing production tag. The patch tag points to the same commit as the production tag.\n\n    Returns:\n        str or None: The newly created patch tag name, or None if no production\n                    tag exists to base the patch on.\n    \"\"\"\n    current_prod = self.get_current_tag(production=True)\n    if current_prod:\n        init_patch_tag = f\"{current_prod}-patch.1\"\n        self.repo.create_tag(\n            init_patch_tag,\n            ref=self.repo.commit(current_prod),\n            message=(\n                f\"Patch version: {init_patch_tag} \" \n                f\"created from Production version: {current_prod}\"\n            )\n        )\n        return init_patch_tag\n\n    return None\n</code></pre>"},{"location":"src/#src.vcm.VersionControlManager.init_new_rc","title":"<code>init_new_rc(prerelease_tag='dev')</code>","text":"<p>Initialize a new release candidate from the current development tag.</p> <p>Creates the first release candidate tag (X.Y.Z-rc.1) based on the highest existing development tag. The RC tag points to the same commit as the dev tag.</p> <p>Parameters:</p> Name Type Description Default <code>prerelease_tag</code> <code>str</code> <p>The development prerelease identifier.                           Defaults to \"dev\".</p> <code>'dev'</code> <p>Returns:</p> Type Description <p>str or None: The newly created RC tag name, or None if no development         tag exists to base the RC on.</p> Source code in <code>src/vcm.py</code> <pre><code>def init_new_rc(self, prerelease_tag: str=\"dev\"):\n    \"\"\"Initialize a new release candidate from the current development tag.\n\n    Creates the first release candidate tag (X.Y.Z-rc.1) based on the highest\n    existing development tag. The RC tag points to the same commit as the dev tag.\n\n    Args:\n        prerelease_tag (str, optional): The development prerelease identifier.\n                                      Defaults to \"dev\".\n\n    Returns:\n        str or None: The newly created RC tag name, or None if no development\n                    tag exists to base the RC on.\n    \"\"\"\n    current_dev_tag = self.get_current_tag(prerelease_tag)\n    if current_dev_tag:\n        t = semver.VersionInfo.parse(current_dev_tag)\n        init_release_tag = f\"{t.major}.{t.minor}.{t.patch}-rc.1\"\n        self.repo.create_tag(\n            init_release_tag,\n            ref=self.repo.commit(current_dev_tag),\n            message=(\n                f\"Release candidate version: {init_release_tag} \" \n                f\"created from Development version: {current_dev_tag}\"\n            )\n        )\n        return init_release_tag\n\n    return None\n</code></pre>"},{"location":"tests/","title":"Tests","text":"<p>Comprehensive integration test suite for VersionControlManager class.</p> <p>This module contains end-to-end integration tests for the VersionControlManager class, testing the complete semantic versioning workflow using a real Git repository. Unlike unit tests that mock Git operations, these tests create actual commits and tags to verify the complete functionality in a realistic environment.</p> Test Strategy <ul> <li>Uses a real Git repository ('test_dir') for authentic testing</li> <li>Creates actual commits and tags to simulate real development workflow</li> <li>Tests complete semantic versioning lifecycle from development to production</li> <li>Validates error handling and business rule enforcement</li> <li>Covers edge cases and version bump scenarios</li> </ul> Workflow Coverage <ol> <li>Development tag creation and incrementing (X.Y.Z-dev.N)</li> <li>Release candidate initialization and management (X.Y.Z-rc.N)</li> <li>Production tag creation from RC tags (X.Y.Z)</li> <li>Patch tag workflow for hotfixes (X.Y.Z-patch.N)</li> <li>Version bumping (minor and major)</li> <li>Error conditions and validation rules</li> </ol> Dependencies <ul> <li>pytest: Testing framework for assertions and exception handling</li> <li>GitPython: Real Git operations (not mocked)</li> <li>os, sys, shutil: File system operations for test cleanup</li> </ul> Test Environment <ul> <li>Creates temporary 'test_dir' Git repository</li> <li>Automatically cleans up test repository after completion</li> <li>Uses sequential test execution that builds upon previous states</li> </ul> <p>Author: Sajin Vachery</p>"},{"location":"tests/#tests.test_vcm.InvalidTagCreation","title":"<code>InvalidTagCreation</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception raised when attempting to create an invalid Git tag.</p> <p>This exception is used to prevent the creation of tags that would violate the versioning rules enforced by the VersionControlManager class.</p> Source code in <code>src/exceptions.py</code> <pre><code>class InvalidTagCreation(Exception):\n    \"\"\"Custom exception raised when attempting to create an invalid Git tag.\n\n    This exception is used to prevent the creation of tags that would violate\n    the versioning rules enforced by the VersionControlManager class.\n    \"\"\"\n    def __init__(self, message=\"Do not try to create an INVALID TAG!\"):\n        self.message = message\n        super().__init__(self.message)\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager","title":"<code>VersionControlManager</code>","text":"<p>A manager class for handling Git tags with semantic versioning.</p> <p>This class provides functionality to create, manage, and increment Git tags following semantic versioning patterns. It supports development, release candidate, patch, and production tags with proper validation and incrementing logic.</p> <p>Attributes:</p> Name Type Description <code>repo</code> <code>Repo</code> <p>The GitPython repository object for the managed repository.</p> Source code in <code>src/vcm.py</code> <pre><code>class VersionControlManager:\n    \"\"\"A manager class for handling Git tags with semantic versioning.\n\n    This class provides functionality to create, manage, and increment Git tags\n    following semantic versioning patterns. It supports development, release candidate,\n    patch, and production tags with proper validation and incrementing logic.\n\n    Attributes:\n        repo (Repo): The GitPython repository object for the managed repository.\n    \"\"\"\n    def __init__(self, repo_path: str):\n        \"\"\"Initialize the VersionControlManager with a repository path.\n\n        If the repository doesn't exist at the given path, it will be created\n        and initialized as a new Git repository.\n\n        Args:\n            repo_path (str): The file system path to the Git repository.\n        \"\"\"\n        if not os.path.isdir(repo_path):\n            os.mkdir(repo_path)\n            self.repo = Repo.init(repo_path)\n        else:\n            self.repo = Repo(repo_path)\n\n\n    @staticmethod\n    def get_init_rc_tag(tag: str):\n        \"\"\"Generate an initial release candidate tag from a prerelease tag.\n\n        Takes a prerelease tag (e.g., \"1.2.3-dev.4\") and converts it to\n        an initial release candidate tag (e.g., \"1.2.3-rc.1\").\n\n        Args:\n            tag (str): A prerelease tag in the format \"X.Y.Z-prerelease.N\"\n\n        Returns:\n            str: The corresponding initial RC tag in format \"X.Y.Z-rc.1\"\n\n        Raises:\n            ValueError: If the tag doesn't match the expected prerelease pattern.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-([a-z]+)\\.(\\d+)$\"\n        if not re.fullmatch(pattern, tag):\n            raise ValueError\n\n        current_tag = semver.VersionInfo.parse(tag)\n        return f\"{current_tag.major}.{current_tag.minor}.{current_tag.patch}-rc.1\"\n\n\n    def find_tag(self, tag: str):\n        \"\"\"Check if a specific tag exists in the repository.\n\n        Performs an exact match search for the given tag name in the repository's\n        tag collection.\n\n        Args:\n            tag (str): The exact tag name to search for.\n\n        Returns:\n            bool: True if the tag exists, False otherwise.\n        \"\"\"\n        pattern = r\"^\" + tag + r\"$\"\n        return any(re.search(pattern,t.name.strip()) for t in self.repo.tags)\n\n\n    def find_tag_with_pattern(self, pattern: str):\n        \"\"\"Find the highest semantic version tag matching a regex pattern.\n\n        Searches through all repository tags for those matching the given regex pattern,\n        then returns the highest version according to semantic versioning rules.\n\n        Args:\n            pattern (str): Regular expression pattern to match against tag names.\n\n        Returns:\n            str or None: The highest semantic version tag matching the pattern,\n                        or None if no matching tags are found.\n        \"\"\"\n        tags = [tag.name.strip() for tag in self.repo.tags if re.search(pattern, tag.name)]\n        sorted_tags = sorted(tags, key=semver.VersionInfo.parse, reverse=True)\n        return sorted_tags[0] if sorted_tags else None\n\n\n    def get_current_tag(self, prerelease_tag: str=\"dev\", production: bool= False):\n        \"\"\"Get the current highest tag for a specific type (prerelease or production).\n\n        Retrieves the highest semantic version tag of either production format (X.Y.Z)\n        or prerelease format (X.Y.Z-prerelease.N) based on the parameters.\n\n        Args:\n            prerelease_tag (str, optional): The prerelease identifier (e.g., \"dev\", \"rc\").\n                                          Defaults to \"dev\".\n            production (bool, optional): If True, searches for production tags (X.Y.Z format).\n                                       If False, searches for prerelease tags. Defaults to False.\n\n        Returns:\n            str or None: The highest matching tag, or None if no matching tags exist.\n        \"\"\"\n        if production:\n            dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n        else:\n            dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-\" + prerelease_tag + r\"\\.(\\d+)$\"\n\n        return self.find_tag_with_pattern(dev_pattern)\n\n\n    def increment_prerelease_tag(self, tag: str=None, prerelease_tag: str=\"dev\", major_bump: bool= False):\n        \"\"\"Create and increment a prerelease tag.\n\n        Creates a new prerelease tag by either incrementing an existing tag or starting\n        a new version sequence. Handles major/minor version bumps when transitioning\n        from one prerelease to another.\n\n        Args:\n            tag (str, optional): Base tag to increment from. If None, starts with \"0.1.0-dev.1\".\n            prerelease_tag (str, optional): The prerelease identifier. Defaults to \"dev\".\n            major_bump (bool, optional): If True, performs a major version bump instead of minor.\n                                       Defaults to False.\n\n        Returns:\n            str: The newly created prerelease tag.\n\n        Raises:\n            ValueError: If the provided tag doesn't match the expected prerelease pattern.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-([a-z]+)\\.(\\d+)$\"\n        if tag:\n            if not re.fullmatch(pattern,tag):\n                raise ValueError\n            if self.find_tag(self.get_init_rc_tag(tag)):\n                if major_bump:\n                    next_tag = f\"{semver.VersionInfo.parse(tag).bump_major()}-{prerelease_tag}.1\"\n                else:\n                    next_tag = f\"{semver.VersionInfo.parse(tag).bump_minor()}-{prerelease_tag}.1\"\n            else:\n                next_tag = semver.VersionInfo.parse(tag).bump_prerelease()\n        else:\n            next_tag = f\"0.1.0-{prerelease_tag}.1\"\n\n        self.repo.create_tag(next_tag)\n        return next_tag\n\n\n    def init_new_rc(self, prerelease_tag: str=\"dev\"):\n        \"\"\"Initialize a new release candidate from the current development tag.\n\n        Creates the first release candidate tag (X.Y.Z-rc.1) based on the highest\n        existing development tag. The RC tag points to the same commit as the dev tag.\n\n        Args:\n            prerelease_tag (str, optional): The development prerelease identifier.\n                                          Defaults to \"dev\".\n\n        Returns:\n            str or None: The newly created RC tag name, or None if no development\n                        tag exists to base the RC on.\n        \"\"\"\n        current_dev_tag = self.get_current_tag(prerelease_tag)\n        if current_dev_tag:\n            t = semver.VersionInfo.parse(current_dev_tag)\n            init_release_tag = f\"{t.major}.{t.minor}.{t.patch}-rc.1\"\n            self.repo.create_tag(\n                init_release_tag,\n                ref=self.repo.commit(current_dev_tag),\n                message=(\n                    f\"Release candidate version: {init_release_tag} \" \n                    f\"created from Development version: {current_dev_tag}\"\n                )\n            )\n            return init_release_tag\n\n        return None\n\n\n    def init_new_patch(self):\n        \"\"\"Initialize a new patch prerelease from the current production tag.\n\n        Creates the first patch prerelease tag (X.Y.Z-patch.1) based on the highest\n        existing production tag. The patch tag points to the same commit as the production tag.\n\n        Returns:\n            str or None: The newly created patch tag name, or None if no production\n                        tag exists to base the patch on.\n        \"\"\"\n        current_prod = self.get_current_tag(production=True)\n        if current_prod:\n            init_patch_tag = f\"{current_prod}-patch.1\"\n            self.repo.create_tag(\n                init_patch_tag,\n                ref=self.repo.commit(current_prod),\n                message=(\n                    f\"Patch version: {init_patch_tag} \" \n                    f\"created from Production version: {current_prod}\"\n                )\n            )\n            return init_patch_tag\n\n        return None\n\n\n    def get_current_rc_patch(self, tag: str, prerelease_tag: str=\"rc\"):\n        \"\"\"Get the current highest RC or patch tag for a given base version.\n\n        Finds the highest prerelease tag (rc or patch) that corresponds to the given\n        base production version tag.\n\n        Args:\n            tag (str): Base production version tag in format \"X.Y.Z\".\n            prerelease_tag (str, optional): The prerelease type (\"rc\" or \"patch\").\n                                           Defaults to \"rc\".\n\n        Returns:\n            str or None: The highest matching prerelease tag, or None if none exist.\n\n        Raises:\n            ValueError: If the base tag doesn't match the production version pattern.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n        if not re.fullmatch(pattern, tag):\n            raise ValueError\n\n        rc_pattern = r\"^\" + tag + r\"-\" + prerelease_tag + r\"\\.(\\d+)$\"\n        return self.find_tag_with_pattern(rc_pattern)\n\n\n    def increment_rc_patch(self, tag: str, prerelease_tag: str=\"rc\"):\n        \"\"\"Increment a release candidate or patch prerelease tag.\n\n        Creates the next RC or patch prerelease tag for a given base version.\n        Includes validation to ensure proper versioning rules are followed.\n\n        Args:\n            tag (str): Base production version tag in format \"X.Y.Z\".\n            prerelease_tag (str, optional): The prerelease type (\"rc\" or \"patch\").\n                                           Defaults to \"rc\".\n\n        Returns:\n            str or None: The newly created incremented tag, or None if no base\n                        prerelease tag exists to increment.\n\n        Raises:\n            ValueError: If the base tag doesn't match the production version pattern.\n            InvalidTagCreation: If attempting to create an RC when production version\n                              exists, or attempting to create a patch when production\n                              version doesn't exist, or when a patch already exists\n                              in production.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n        if not re.fullmatch(pattern, tag):\n            raise ValueError\n\n        if  prerelease_tag == \"rc\" and self.find_tag(tag):\n            raise InvalidTagCreation(\n                \"Production version available. Cannot create Release Candidate version!\"\n            )\n        elif prerelease_tag == \"patch\" and not self.find_tag(tag):\n            raise InvalidTagCreation(\n                \"Production version not available. Cannot create Patch version!\"\n            )\n        elif prerelease_tag == \"rc\":\n            current_rc = self.get_current_rc_patch(tag)\n        elif prerelease_tag == \"patch\":\n            if self.find_tag(str(semver.VersionInfo.parse(tag).bump_patch())):\n                raise InvalidTagCreation(\n                    \"Cannot increment Patch pre-release version. Patch found in Production.\"\n                )\n            current_rc = self.get_current_rc_patch(tag, \"patch\")\n\n        if current_rc:\n            new_rc_tag = semver.VersionInfo.parse(current_rc).bump_prerelease()\n            self.repo.create_tag(new_rc_tag)\n            return new_rc_tag\n\n        return None\n\n\n    def create_prod_tag(self, tag: str):\n        \"\"\"Create a production tag from a release candidate or patch prerelease.\n\n        Converts an RC or patch prerelease tag into a production version tag.\n        For RC tags, creates the base version (X.Y.Z). For patch tags, creates\n        the next patch version (X.Y.Z+1).\n\n        Args:\n            tag (str): The RC or patch prerelease tag to promote to production.\n                      Format: \"X.Y.Z-rc.N\" or \"X.Y.Z-patch.N\".\n\n        Returns:\n            str: The newly created production tag.\n\n        Raises:\n            ValueError: If the tag doesn't match the expected RC or patch pattern.\n        \"\"\"\n        pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-(rc|patch)\\.(\\d+)$\"\n        if not re.fullmatch(pattern, tag):\n            raise ValueError\n\n        if re.match(pattern,tag).group(4) == \"patch\":\n            new_prod_tag = semver.VersionInfo.parse(tag).bump_patch()\n        else:\n            t = semver.VersionInfo.parse(tag)\n            new_prod_tag = f\"{t.major}.{t.minor}.{t.patch}\"\n\n        self.repo.create_tag(\n            new_prod_tag,\n            ref=self.repo.commit(tag),\n            message=(\n                f\"Production version: {new_prod_tag} \"\n                f\"created from (Release Candidate | Patch) version: {tag}\"\n            )\n        )\n        return new_prod_tag\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.__init__","title":"<code>__init__(repo_path)</code>","text":"<p>Initialize the VersionControlManager with a repository path.</p> <p>If the repository doesn't exist at the given path, it will be created and initialized as a new Git repository.</p> <p>Parameters:</p> Name Type Description Default <code>repo_path</code> <code>str</code> <p>The file system path to the Git repository.</p> required Source code in <code>src/vcm.py</code> <pre><code>def __init__(self, repo_path: str):\n    \"\"\"Initialize the VersionControlManager with a repository path.\n\n    If the repository doesn't exist at the given path, it will be created\n    and initialized as a new Git repository.\n\n    Args:\n        repo_path (str): The file system path to the Git repository.\n    \"\"\"\n    if not os.path.isdir(repo_path):\n        os.mkdir(repo_path)\n        self.repo = Repo.init(repo_path)\n    else:\n        self.repo = Repo(repo_path)\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.create_prod_tag","title":"<code>create_prod_tag(tag)</code>","text":"<p>Create a production tag from a release candidate or patch prerelease.</p> <p>Converts an RC or patch prerelease tag into a production version tag. For RC tags, creates the base version (X.Y.Z). For patch tags, creates the next patch version (X.Y.Z+1).</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The RC or patch prerelease tag to promote to production.       Format: \"X.Y.Z-rc.N\" or \"X.Y.Z-patch.N\".</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The newly created production tag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag doesn't match the expected RC or patch pattern.</p> Source code in <code>src/vcm.py</code> <pre><code>def create_prod_tag(self, tag: str):\n    \"\"\"Create a production tag from a release candidate or patch prerelease.\n\n    Converts an RC or patch prerelease tag into a production version tag.\n    For RC tags, creates the base version (X.Y.Z). For patch tags, creates\n    the next patch version (X.Y.Z+1).\n\n    Args:\n        tag (str): The RC or patch prerelease tag to promote to production.\n                  Format: \"X.Y.Z-rc.N\" or \"X.Y.Z-patch.N\".\n\n    Returns:\n        str: The newly created production tag.\n\n    Raises:\n        ValueError: If the tag doesn't match the expected RC or patch pattern.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-(rc|patch)\\.(\\d+)$\"\n    if not re.fullmatch(pattern, tag):\n        raise ValueError\n\n    if re.match(pattern,tag).group(4) == \"patch\":\n        new_prod_tag = semver.VersionInfo.parse(tag).bump_patch()\n    else:\n        t = semver.VersionInfo.parse(tag)\n        new_prod_tag = f\"{t.major}.{t.minor}.{t.patch}\"\n\n    self.repo.create_tag(\n        new_prod_tag,\n        ref=self.repo.commit(tag),\n        message=(\n            f\"Production version: {new_prod_tag} \"\n            f\"created from (Release Candidate | Patch) version: {tag}\"\n        )\n    )\n    return new_prod_tag\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.find_tag","title":"<code>find_tag(tag)</code>","text":"<p>Check if a specific tag exists in the repository.</p> <p>Performs an exact match search for the given tag name in the repository's tag collection.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The exact tag name to search for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the tag exists, False otherwise.</p> Source code in <code>src/vcm.py</code> <pre><code>def find_tag(self, tag: str):\n    \"\"\"Check if a specific tag exists in the repository.\n\n    Performs an exact match search for the given tag name in the repository's\n    tag collection.\n\n    Args:\n        tag (str): The exact tag name to search for.\n\n    Returns:\n        bool: True if the tag exists, False otherwise.\n    \"\"\"\n    pattern = r\"^\" + tag + r\"$\"\n    return any(re.search(pattern,t.name.strip()) for t in self.repo.tags)\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.find_tag_with_pattern","title":"<code>find_tag_with_pattern(pattern)</code>","text":"<p>Find the highest semantic version tag matching a regex pattern.</p> <p>Searches through all repository tags for those matching the given regex pattern, then returns the highest version according to semantic versioning rules.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regular expression pattern to match against tag names.</p> required <p>Returns:</p> Type Description <p>str or None: The highest semantic version tag matching the pattern,         or None if no matching tags are found.</p> Source code in <code>src/vcm.py</code> <pre><code>def find_tag_with_pattern(self, pattern: str):\n    \"\"\"Find the highest semantic version tag matching a regex pattern.\n\n    Searches through all repository tags for those matching the given regex pattern,\n    then returns the highest version according to semantic versioning rules.\n\n    Args:\n        pattern (str): Regular expression pattern to match against tag names.\n\n    Returns:\n        str or None: The highest semantic version tag matching the pattern,\n                    or None if no matching tags are found.\n    \"\"\"\n    tags = [tag.name.strip() for tag in self.repo.tags if re.search(pattern, tag.name)]\n    sorted_tags = sorted(tags, key=semver.VersionInfo.parse, reverse=True)\n    return sorted_tags[0] if sorted_tags else None\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.get_current_rc_patch","title":"<code>get_current_rc_patch(tag, prerelease_tag='rc')</code>","text":"<p>Get the current highest RC or patch tag for a given base version.</p> <p>Finds the highest prerelease tag (rc or patch) that corresponds to the given base production version tag.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Base production version tag in format \"X.Y.Z\".</p> required <code>prerelease_tag</code> <code>str</code> <p>The prerelease type (\"rc\" or \"patch\").                            Defaults to \"rc\".</p> <code>'rc'</code> <p>Returns:</p> Type Description <p>str or None: The highest matching prerelease tag, or None if none exist.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the base tag doesn't match the production version pattern.</p> Source code in <code>src/vcm.py</code> <pre><code>def get_current_rc_patch(self, tag: str, prerelease_tag: str=\"rc\"):\n    \"\"\"Get the current highest RC or patch tag for a given base version.\n\n    Finds the highest prerelease tag (rc or patch) that corresponds to the given\n    base production version tag.\n\n    Args:\n        tag (str): Base production version tag in format \"X.Y.Z\".\n        prerelease_tag (str, optional): The prerelease type (\"rc\" or \"patch\").\n                                       Defaults to \"rc\".\n\n    Returns:\n        str or None: The highest matching prerelease tag, or None if none exist.\n\n    Raises:\n        ValueError: If the base tag doesn't match the production version pattern.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n    if not re.fullmatch(pattern, tag):\n        raise ValueError\n\n    rc_pattern = r\"^\" + tag + r\"-\" + prerelease_tag + r\"\\.(\\d+)$\"\n    return self.find_tag_with_pattern(rc_pattern)\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.get_current_tag","title":"<code>get_current_tag(prerelease_tag='dev', production=False)</code>","text":"<p>Get the current highest tag for a specific type (prerelease or production).</p> <p>Retrieves the highest semantic version tag of either production format (X.Y.Z) or prerelease format (X.Y.Z-prerelease.N) based on the parameters.</p> <p>Parameters:</p> Name Type Description Default <code>prerelease_tag</code> <code>str</code> <p>The prerelease identifier (e.g., \"dev\", \"rc\").                           Defaults to \"dev\".</p> <code>'dev'</code> <code>production</code> <code>bool</code> <p>If True, searches for production tags (X.Y.Z format).                        If False, searches for prerelease tags. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <p>str or None: The highest matching tag, or None if no matching tags exist.</p> Source code in <code>src/vcm.py</code> <pre><code>def get_current_tag(self, prerelease_tag: str=\"dev\", production: bool= False):\n    \"\"\"Get the current highest tag for a specific type (prerelease or production).\n\n    Retrieves the highest semantic version tag of either production format (X.Y.Z)\n    or prerelease format (X.Y.Z-prerelease.N) based on the parameters.\n\n    Args:\n        prerelease_tag (str, optional): The prerelease identifier (e.g., \"dev\", \"rc\").\n                                      Defaults to \"dev\".\n        production (bool, optional): If True, searches for production tags (X.Y.Z format).\n                                   If False, searches for prerelease tags. Defaults to False.\n\n    Returns:\n        str or None: The highest matching tag, or None if no matching tags exist.\n    \"\"\"\n    if production:\n        dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n    else:\n        dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-\" + prerelease_tag + r\"\\.(\\d+)$\"\n\n    return self.find_tag_with_pattern(dev_pattern)\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.get_init_rc_tag","title":"<code>get_init_rc_tag(tag)</code>  <code>staticmethod</code>","text":"<p>Generate an initial release candidate tag from a prerelease tag.</p> <p>Takes a prerelease tag (e.g., \"1.2.3-dev.4\") and converts it to an initial release candidate tag (e.g., \"1.2.3-rc.1\").</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>A prerelease tag in the format \"X.Y.Z-prerelease.N\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The corresponding initial RC tag in format \"X.Y.Z-rc.1\"</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tag doesn't match the expected prerelease pattern.</p> Source code in <code>src/vcm.py</code> <pre><code>@staticmethod\ndef get_init_rc_tag(tag: str):\n    \"\"\"Generate an initial release candidate tag from a prerelease tag.\n\n    Takes a prerelease tag (e.g., \"1.2.3-dev.4\") and converts it to\n    an initial release candidate tag (e.g., \"1.2.3-rc.1\").\n\n    Args:\n        tag (str): A prerelease tag in the format \"X.Y.Z-prerelease.N\"\n\n    Returns:\n        str: The corresponding initial RC tag in format \"X.Y.Z-rc.1\"\n\n    Raises:\n        ValueError: If the tag doesn't match the expected prerelease pattern.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-([a-z]+)\\.(\\d+)$\"\n    if not re.fullmatch(pattern, tag):\n        raise ValueError\n\n    current_tag = semver.VersionInfo.parse(tag)\n    return f\"{current_tag.major}.{current_tag.minor}.{current_tag.patch}-rc.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.increment_prerelease_tag","title":"<code>increment_prerelease_tag(tag=None, prerelease_tag='dev', major_bump=False)</code>","text":"<p>Create and increment a prerelease tag.</p> <p>Creates a new prerelease tag by either incrementing an existing tag or starting a new version sequence. Handles major/minor version bumps when transitioning from one prerelease to another.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Base tag to increment from. If None, starts with \"0.1.0-dev.1\".</p> <code>None</code> <code>prerelease_tag</code> <code>str</code> <p>The prerelease identifier. Defaults to \"dev\".</p> <code>'dev'</code> <code>major_bump</code> <code>bool</code> <p>If True, performs a major version bump instead of minor.                        Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The newly created prerelease tag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided tag doesn't match the expected prerelease pattern.</p> Source code in <code>src/vcm.py</code> <pre><code>def increment_prerelease_tag(self, tag: str=None, prerelease_tag: str=\"dev\", major_bump: bool= False):\n    \"\"\"Create and increment a prerelease tag.\n\n    Creates a new prerelease tag by either incrementing an existing tag or starting\n    a new version sequence. Handles major/minor version bumps when transitioning\n    from one prerelease to another.\n\n    Args:\n        tag (str, optional): Base tag to increment from. If None, starts with \"0.1.0-dev.1\".\n        prerelease_tag (str, optional): The prerelease identifier. Defaults to \"dev\".\n        major_bump (bool, optional): If True, performs a major version bump instead of minor.\n                                   Defaults to False.\n\n    Returns:\n        str: The newly created prerelease tag.\n\n    Raises:\n        ValueError: If the provided tag doesn't match the expected prerelease pattern.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-([a-z]+)\\.(\\d+)$\"\n    if tag:\n        if not re.fullmatch(pattern,tag):\n            raise ValueError\n        if self.find_tag(self.get_init_rc_tag(tag)):\n            if major_bump:\n                next_tag = f\"{semver.VersionInfo.parse(tag).bump_major()}-{prerelease_tag}.1\"\n            else:\n                next_tag = f\"{semver.VersionInfo.parse(tag).bump_minor()}-{prerelease_tag}.1\"\n        else:\n            next_tag = semver.VersionInfo.parse(tag).bump_prerelease()\n    else:\n        next_tag = f\"0.1.0-{prerelease_tag}.1\"\n\n    self.repo.create_tag(next_tag)\n    return next_tag\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.increment_rc_patch","title":"<code>increment_rc_patch(tag, prerelease_tag='rc')</code>","text":"<p>Increment a release candidate or patch prerelease tag.</p> <p>Creates the next RC or patch prerelease tag for a given base version. Includes validation to ensure proper versioning rules are followed.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Base production version tag in format \"X.Y.Z\".</p> required <code>prerelease_tag</code> <code>str</code> <p>The prerelease type (\"rc\" or \"patch\").                            Defaults to \"rc\".</p> <code>'rc'</code> <p>Returns:</p> Type Description <p>str or None: The newly created incremented tag, or None if no base         prerelease tag exists to increment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the base tag doesn't match the production version pattern.</p> <code>InvalidTagCreation</code> <p>If attempting to create an RC when production version               exists, or attempting to create a patch when production               version doesn't exist, or when a patch already exists               in production.</p> Source code in <code>src/vcm.py</code> <pre><code>def increment_rc_patch(self, tag: str, prerelease_tag: str=\"rc\"):\n    \"\"\"Increment a release candidate or patch prerelease tag.\n\n    Creates the next RC or patch prerelease tag for a given base version.\n    Includes validation to ensure proper versioning rules are followed.\n\n    Args:\n        tag (str): Base production version tag in format \"X.Y.Z\".\n        prerelease_tag (str, optional): The prerelease type (\"rc\" or \"patch\").\n                                       Defaults to \"rc\".\n\n    Returns:\n        str or None: The newly created incremented tag, or None if no base\n                    prerelease tag exists to increment.\n\n    Raises:\n        ValueError: If the base tag doesn't match the production version pattern.\n        InvalidTagCreation: If attempting to create an RC when production version\n                          exists, or attempting to create a patch when production\n                          version doesn't exist, or when a patch already exists\n                          in production.\n    \"\"\"\n    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n    if not re.fullmatch(pattern, tag):\n        raise ValueError\n\n    if  prerelease_tag == \"rc\" and self.find_tag(tag):\n        raise InvalidTagCreation(\n            \"Production version available. Cannot create Release Candidate version!\"\n        )\n    elif prerelease_tag == \"patch\" and not self.find_tag(tag):\n        raise InvalidTagCreation(\n            \"Production version not available. Cannot create Patch version!\"\n        )\n    elif prerelease_tag == \"rc\":\n        current_rc = self.get_current_rc_patch(tag)\n    elif prerelease_tag == \"patch\":\n        if self.find_tag(str(semver.VersionInfo.parse(tag).bump_patch())):\n            raise InvalidTagCreation(\n                \"Cannot increment Patch pre-release version. Patch found in Production.\"\n            )\n        current_rc = self.get_current_rc_patch(tag, \"patch\")\n\n    if current_rc:\n        new_rc_tag = semver.VersionInfo.parse(current_rc).bump_prerelease()\n        self.repo.create_tag(new_rc_tag)\n        return new_rc_tag\n\n    return None\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.init_new_patch","title":"<code>init_new_patch()</code>","text":"<p>Initialize a new patch prerelease from the current production tag.</p> <p>Creates the first patch prerelease tag (X.Y.Z-patch.1) based on the highest existing production tag. The patch tag points to the same commit as the production tag.</p> <p>Returns:</p> Type Description <p>str or None: The newly created patch tag name, or None if no production         tag exists to base the patch on.</p> Source code in <code>src/vcm.py</code> <pre><code>def init_new_patch(self):\n    \"\"\"Initialize a new patch prerelease from the current production tag.\n\n    Creates the first patch prerelease tag (X.Y.Z-patch.1) based on the highest\n    existing production tag. The patch tag points to the same commit as the production tag.\n\n    Returns:\n        str or None: The newly created patch tag name, or None if no production\n                    tag exists to base the patch on.\n    \"\"\"\n    current_prod = self.get_current_tag(production=True)\n    if current_prod:\n        init_patch_tag = f\"{current_prod}-patch.1\"\n        self.repo.create_tag(\n            init_patch_tag,\n            ref=self.repo.commit(current_prod),\n            message=(\n                f\"Patch version: {init_patch_tag} \" \n                f\"created from Production version: {current_prod}\"\n            )\n        )\n        return init_patch_tag\n\n    return None\n</code></pre>"},{"location":"tests/#tests.test_vcm.VersionControlManager.init_new_rc","title":"<code>init_new_rc(prerelease_tag='dev')</code>","text":"<p>Initialize a new release candidate from the current development tag.</p> <p>Creates the first release candidate tag (X.Y.Z-rc.1) based on the highest existing development tag. The RC tag points to the same commit as the dev tag.</p> <p>Parameters:</p> Name Type Description Default <code>prerelease_tag</code> <code>str</code> <p>The development prerelease identifier.                           Defaults to \"dev\".</p> <code>'dev'</code> <p>Returns:</p> Type Description <p>str or None: The newly created RC tag name, or None if no development         tag exists to base the RC on.</p> Source code in <code>src/vcm.py</code> <pre><code>def init_new_rc(self, prerelease_tag: str=\"dev\"):\n    \"\"\"Initialize a new release candidate from the current development tag.\n\n    Creates the first release candidate tag (X.Y.Z-rc.1) based on the highest\n    existing development tag. The RC tag points to the same commit as the dev tag.\n\n    Args:\n        prerelease_tag (str, optional): The development prerelease identifier.\n                                      Defaults to \"dev\".\n\n    Returns:\n        str or None: The newly created RC tag name, or None if no development\n                    tag exists to base the RC on.\n    \"\"\"\n    current_dev_tag = self.get_current_tag(prerelease_tag)\n    if current_dev_tag:\n        t = semver.VersionInfo.parse(current_dev_tag)\n        init_release_tag = f\"{t.major}.{t.minor}.{t.patch}-rc.1\"\n        self.repo.create_tag(\n            init_release_tag,\n            ref=self.repo.commit(current_dev_tag),\n            message=(\n                f\"Release candidate version: {init_release_tag} \" \n                f\"created from Development version: {current_dev_tag}\"\n            )\n        )\n        return init_release_tag\n\n    return None\n</code></pre>"},{"location":"tests/#tests.test_vcm.create_tag","title":"<code>create_tag(tag)</code>","text":"<p>Create a specific tag in the test repository.</p> <p>This utility function creates a Git tag with the given name in the test repository. It's used to set up test scenarios that require specific tags to exist before testing VersionControlManager functionality.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag name to create (should follow semantic versioning)</p> required Side Effects <ul> <li>Creates a new Git tag in the test repository</li> <li>Tag points to the current HEAD commit</li> </ul> Note <p>This function bypasses VersionControlManager's validation and directly creates tags via GitPython, allowing test setup that might not be possible through the manager's normal workflow.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def create_tag(tag):\n    \"\"\"Create a specific tag in the test repository.\n\n    This utility function creates a Git tag with the given name in the\n    test repository. It's used to set up test scenarios that require\n    specific tags to exist before testing VersionControlManager functionality.\n\n    Args:\n        tag (str): The tag name to create (should follow semantic versioning)\n\n    Side Effects:\n        - Creates a new Git tag in the test repository\n        - Tag points to the current HEAD commit\n\n    Note:\n        This function bypasses VersionControlManager's validation and directly\n        creates tags via GitPython, allowing test setup that might not\n        be possible through the manager's normal workflow.\n    \"\"\"\n    test_dir = \"test_dir\"\n    test_repo = git.Repo(\"test_dir\")\n    test_repo.create_tag(tag)\n</code></pre>"},{"location":"tests/#tests.test_vcm.create_tags","title":"<code>create_tags()</code>","text":"<p>Create a sequence of development tags for testing.</p> <p>This setup function creates a series of development tags (1.0.0-dev.0 through 1.0.0-dev.9) with corresponding commits. This simulates a development workflow where multiple development iterations have occurred.</p> <p>The function creates both commits and tags to establish a realistic repository state for testing tag management operations.</p> Created Tags <ul> <li>1.0.0-dev.0 through 1.0.0-dev.9 (10 development tags total)</li> </ul> Side Effects <ul> <li>Creates 10 empty commits in the repository</li> <li>Creates 10 development tags pointing to these commits</li> <li>Establishes a baseline for subsequent tag operations</li> </ul> Usage <p>Typically called once during test setup to create a repository state that allows testing of tag incrementing, RC creation, and other advanced operations.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def create_tags():\n    \"\"\"Create a sequence of development tags for testing.\n\n    This setup function creates a series of development tags (1.0.0-dev.0\n    through 1.0.0-dev.9) with corresponding commits. This simulates a\n    development workflow where multiple development iterations have occurred.\n\n    The function creates both commits and tags to establish a realistic\n    repository state for testing tag management operations.\n\n    Created Tags:\n        - 1.0.0-dev.0 through 1.0.0-dev.9 (10 development tags total)\n\n    Side Effects:\n        - Creates 10 empty commits in the repository\n        - Creates 10 development tags pointing to these commits\n        - Establishes a baseline for subsequent tag operations\n\n    Usage:\n        Typically called once during test setup to create a repository\n        state that allows testing of tag incrementing, RC creation, and\n        other advanced operations.\n    \"\"\"\n    for i in range(10):\n        empty_commit()\n        create_tag(f\"1.0.0-dev.{i}\")\n</code></pre>"},{"location":"tests/#tests.test_vcm.empty_commit","title":"<code>empty_commit()</code>","text":"<p>Create an empty commit in the test repository.</p> <p>This utility function creates a commit in the test repository without adding any files. It's used to advance the commit history so that new tags can be created at different commit points, simulating real development progress.</p> <p>The function operates on the global 'test_dir' repository and is essential for tag creation since Git requires commits to exist before tags can be created.</p> Side Effects <ul> <li>Creates a new commit in the test repository</li> <li>Advances the repository's commit history</li> <li>Enables subsequent tag creation</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def empty_commit():\n    \"\"\"Create an empty commit in the test repository.\n\n    This utility function creates a commit in the test repository without\n    adding any files. It's used to advance the commit history so that\n    new tags can be created at different commit points, simulating\n    real development progress.\n\n    The function operates on the global 'test_dir' repository and is\n    essential for tag creation since Git requires commits to exist\n    before tags can be created.\n\n    Side Effects:\n        - Creates a new commit in the test repository\n        - Advances the repository's commit history\n        - Enables subsequent tag creation\n    \"\"\"\n    test_dir = \"test_dir\"\n    test_repo = git.Repo(\"test_dir\")\n    test_repo.index.commit(f\"Empty Commit\")\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_complete_multi_version_workflow","title":"<code>test_complete_multi_version_workflow()</code>","text":"<p>Test complete multi-version development workflow.</p> <p>This comprehensive test simulates a realistic multi-version development scenario with overlapping releases, patches, and development cycles. It validates the complete system behavior over an extended period.</p> Test Workflow <ol> <li>Complete 2.1.0 release cycle (RC \u2192 production)</li> <li>Start 2.2.0 development with minor bump</li> <li>Create patch for 2.1.0 while 2.2.0 development continues</li> <li>Start major 3.0.0 development cycle</li> <li>Validate all version families coexist correctly</li> </ol> Validates <ul> <li>Multi-version workflow management</li> <li>Version family independence</li> <li>Concurrent development and patch workflows</li> <li>Long-term version history integrity</li> <li>Complex version state management</li> </ul> Business Logic Tested <ul> <li>Complete workflow cycles across multiple versions</li> <li>Version family separation and coexistence</li> <li>Long-term tag management and retrieval</li> <li>Complex version state scenarios</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_complete_multi_version_workflow():\n    \"\"\"Test complete multi-version development workflow.\n\n    This comprehensive test simulates a realistic multi-version development\n    scenario with overlapping releases, patches, and development cycles.\n    It validates the complete system behavior over an extended period.\n\n    Test Workflow:\n        1. Complete 2.1.0 release cycle (RC \u2192 production)\n        2. Start 2.2.0 development with minor bump\n        3. Create patch for 2.1.0 while 2.2.0 development continues\n        4. Start major 3.0.0 development cycle\n        5. Validate all version families coexist correctly\n\n    Validates:\n        - Multi-version workflow management\n        - Version family independence\n        - Concurrent development and patch workflows\n        - Long-term version history integrity\n        - Complex version state management\n\n    Business Logic Tested:\n        - Complete workflow cycles across multiple versions\n        - Version family separation and coexistence\n        - Long-term tag management and retrieval\n        - Complex version state scenarios\n    \"\"\"\n    # Complete 2.1.0 release cycle\n    assert manager.create_prod_tag(\"2.1.0-rc.1\") == \"2.1.0\"\n    assert manager.get_current_tag(production=True) == \"2.1.0\"\n\n    # Start 2.2.0 development (minor bump)\n    assert manager.increment_prerelease_tag(\"2.1.0-dev.3\") == \"2.2.0-dev.1\"\n    assert manager.increment_prerelease_tag(\"2.2.0-dev.1\") == \"2.2.0-dev.2\"\n\n    # Meanwhile, create patch for 2.1.0\n    empty_commit()  # Need commit for patch tag\n    create_tag(\"2.1.0-patch.1\")  # Direct creation to simulate hotfix\n    assert manager.increment_rc_patch(\"2.1.0\", \"patch\") == \"2.1.0-patch.2\"\n    assert manager.create_prod_tag(\"2.1.0-patch.2\") == \"2.1.1\"\n\n    # Start major 3.0.0 development cycle\n    assert manager.init_new_rc() == \"2.2.0-rc.1\"\n    assert manager.increment_prerelease_tag(\"2.2.0-dev.2\", major_bump=True) == \"3.0.0-dev.1\"\n\n    # Validate current states across all version families\n    assert manager.get_current_tag() == \"3.0.0-dev.1\"  # Latest development\n    assert manager.get_current_tag(production=True) == \"2.1.1\"  # Latest production\n\n    # Create RC for 3.0.0\n    assert manager.init_new_rc() == \"3.0.0-rc.1\"\n    assert manager.create_prod_tag(\"3.0.0-rc.1\") == \"3.0.0\"\n\n    # Final state validation\n    assert manager.get_current_tag(production=True) == \"3.0.0\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_create_prod_from_patch","title":"<code>test_create_prod_from_patch()</code>","text":"<p>Test production tag creation from patch prerelease.</p> <p>This test verifies the VersionControlManager's ability to promote a tested patch prerelease to a production patch version. This completes the hotfix workflow by creating an official patch release.</p> Test Scenario <ul> <li>Promote patch \"1.0.0-patch.2\" to production \"1.0.1\"</li> </ul> Validates <ul> <li>Patch to production tag conversion</li> <li>Automatic patch number increment (1.0.0 \u2192 1.0.1)</li> <li>Hotfix workflow completion</li> <li>Production tag creation with proper commit reference</li> </ul> Business Logic Tested <ul> <li>create_prod_tag() method with patch prerelease parameter</li> <li>Patch version incrementing rules</li> <li>Production tag naming for patches</li> <li>Hotfix to production workflow transition</li> </ul> Workflow Context <p>This represents the completion of a hotfix cycle where a thoroughly tested patch is promoted to production, creating an official patch release (1.0.1) that fixes issues in 1.0.0.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_create_prod_from_patch():\n    \"\"\"Test production tag creation from patch prerelease.\n\n    This test verifies the VersionControlManager's ability to promote a tested\n    patch prerelease to a production patch version. This completes the\n    hotfix workflow by creating an official patch release.\n\n    Test Scenario:\n        - Promote patch \"1.0.0-patch.2\" to production \"1.0.1\"\n\n    Validates:\n        - Patch to production tag conversion\n        - Automatic patch number increment (1.0.0 \u2192 1.0.1)\n        - Hotfix workflow completion\n        - Production tag creation with proper commit reference\n\n    Business Logic Tested:\n        - create_prod_tag() method with patch prerelease parameter\n        - Patch version incrementing rules\n        - Production tag naming for patches\n        - Hotfix to production workflow transition\n\n    Workflow Context:\n        This represents the completion of a hotfix cycle where a\n        thoroughly tested patch is promoted to production, creating\n        an official patch release (1.0.1) that fixes issues in 1.0.0.\n    \"\"\"\n    assert manager.create_prod_tag(\"1.0.0-patch.2\") == \"1.0.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_current_tag","title":"<code>test_current_tag()</code>","text":"<p>Test current tag retrieval functionality.</p> <p>This test verifies the VersionControlManager's ability to identify and return the current highest development tag. It tests both empty repository scenarios and repositories with multiple development tags.</p> Test Scenario <ol> <li>Start with empty repository (should return None)</li> <li>Create first development tag and verify retrieval</li> <li>Create multiple development tags and verify highest is returned</li> </ol> Validates <ul> <li>Empty repository handling (returns None)</li> <li>Initial tag creation (0.1.0-dev.1)</li> <li>Highest tag identification from multiple options</li> <li>Semantic version sorting (1.0.0-dev.9 &gt; 0.1.0-dev.1)</li> </ul> Business Logic Tested <ul> <li>get_current_tag() with default \"dev\" prerelease identifier</li> <li>increment_prerelease_tag() initial tag creation</li> <li>Proper semantic version comparison and sorting</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_current_tag():\n    \"\"\"Test current tag retrieval functionality.\n\n    This test verifies the VersionControlManager's ability to identify and return\n    the current highest development tag. It tests both empty repository\n    scenarios and repositories with multiple development tags.\n\n    Test Scenario:\n        1. Start with empty repository (should return None)\n        2. Create first development tag and verify retrieval\n        3. Create multiple development tags and verify highest is returned\n\n    Validates:\n        - Empty repository handling (returns None)\n        - Initial tag creation (0.1.0-dev.1)\n        - Highest tag identification from multiple options\n        - Semantic version sorting (1.0.0-dev.9 &gt; 0.1.0-dev.1)\n\n    Business Logic Tested:\n        - get_current_tag() with default \"dev\" prerelease identifier\n        - increment_prerelease_tag() initial tag creation\n        - Proper semantic version comparison and sorting\n    \"\"\"\n    assert manager.get_current_tag() is None\n    empty_commit()\n    assert manager.increment_prerelease_tag() == \"0.1.0-dev.1\"\n    assert manager.get_current_tag() == \"0.1.0-dev.1\"\n    create_tags()\n    assert manager.get_current_tag() == \"1.0.0-dev.9\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_edge_cases_and_boundaries","title":"<code>test_edge_cases_and_boundaries()</code>","text":"<p>Test edge cases and boundary conditions.</p> <p>This test covers various edge cases that might occur in real-world usage, ensuring the VersionControlManager is robust and handles unusual but valid scenarios correctly.</p> Test Scenarios <ol> <li>Version number boundaries (0.0.0, high numbers)</li> <li>Empty repository initialization</li> <li>Tag creation from initial state</li> <li>Pattern matching edge cases</li> </ol> Validates <ul> <li>Robustness with edge case version numbers</li> <li>Proper handling of empty repository states</li> <li>Initial tag creation workflows</li> <li>Pattern matching accuracy with various formats</li> </ul> Business Logic Tested <ul> <li>Version number parsing and validation</li> <li>Initial state handling</li> <li>Pattern matching reliability</li> <li>Boundary condition handling</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_edge_cases_and_boundaries():\n    \"\"\"Test edge cases and boundary conditions.\n\n    This test covers various edge cases that might occur in real-world\n    usage, ensuring the VersionControlManager is robust and handles unusual\n    but valid scenarios correctly.\n\n    Test Scenarios:\n        1. Version number boundaries (0.0.0, high numbers)\n        2. Empty repository initialization\n        3. Tag creation from initial state\n        4. Pattern matching edge cases\n\n    Validates:\n        - Robustness with edge case version numbers\n        - Proper handling of empty repository states\n        - Initial tag creation workflows\n        - Pattern matching accuracy with various formats\n\n    Business Logic Tested:\n        - Version number parsing and validation\n        - Initial state handling\n        - Pattern matching reliability\n        - Boundary condition handling\n    \"\"\"\n    # Test with version boundaries\n    assert manager.get_init_rc_tag(\"0.0.1-dev.1\") == \"0.0.1-rc.1\"\n    assert manager.get_init_rc_tag(\"999.999.999-dev.1\") == \"999.999.999-rc.1\"\n\n    # Test pattern matching with existing tags\n    dev_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)-dev\\.(\\d+)$\"\n    result = manager.find_tag_with_pattern(dev_pattern)\n    assert result == \"2.1.0-dev.3\"  # Should find highest dev tag\n\n    # Test production pattern matching\n    prod_pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n    result = manager.find_tag_with_pattern(prod_pattern)\n    assert result in [\"2.0.3\", \"2.0.2\"]  # Should find one of the high production tags\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_find_tag","title":"<code>test_find_tag()</code>","text":"<p>Test tag existence checking functionality.</p> <p>This test verifies the VersionControlManager's ability to check whether specific tags exist in the repository. It tests both positive (tag exists) and negative (tag doesn't exist) cases.</p> Test Scenarios <ol> <li>Search for non-existent tag (should return False)</li> <li>Search for existing tag (should return True)</li> </ol> Validates <ul> <li>Accurate tag existence detection</li> <li>Case-sensitive tag name matching</li> <li>Repository tag collection querying</li> </ul> Business Logic Tested <ul> <li>find_tag() method with exact tag name matching</li> <li>Repository tag enumeration and comparison</li> <li>Boolean return values for existence checks</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_find_tag():\n    \"\"\"Test tag existence checking functionality.\n\n    This test verifies the VersionControlManager's ability to check whether\n    specific tags exist in the repository. It tests both positive\n    (tag exists) and negative (tag doesn't exist) cases.\n\n    Test Scenarios:\n        1. Search for non-existent tag (should return False)\n        2. Search for existing tag (should return True)\n\n    Validates:\n        - Accurate tag existence detection\n        - Case-sensitive tag name matching\n        - Repository tag collection querying\n\n    Business Logic Tested:\n        - find_tag() method with exact tag name matching\n        - Repository tag enumeration and comparison\n        - Boolean return values for existence checks\n    \"\"\"\n    assert not manager.find_tag(\"test\")\n    assert manager.find_tag(\"1.0.0-dev.10\")\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_get_current_patch","title":"<code>test_get_current_patch()</code>","text":"<p>Test patch tag retrieval for versions without patches.</p> <p>This test verifies that the VersionControlManager correctly handles queries for patch tags when no patch versions exist. This establishes the baseline before patch tag creation and tests proper None handling.</p> Test Scenarios <ol> <li>Query patch for version \"1.0.0\" (production exists, no patches)</li> <li>Query patch for version \"1.1.0\" (no production, no patches)</li> </ol> <p>Both should return None since no patch tags exist yet.</p> Validates <ul> <li>Proper None return for non-existent patch tags</li> <li>Patch tag querying for different version states</li> <li>Baseline establishment for patch workflow testing</li> </ul> Business Logic Tested <ul> <li>get_current_rc_patch() method with \"patch\" prerelease type</li> <li>Pattern matching for patch tags</li> <li>Handling of non-existent tag scenarios</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_get_current_patch():\n    \"\"\"Test patch tag retrieval for versions without patches.\n\n    This test verifies that the VersionControlManager correctly handles queries\n    for patch tags when no patch versions exist. This establishes the\n    baseline before patch tag creation and tests proper None handling.\n\n    Test Scenarios:\n        1. Query patch for version \"1.0.0\" (production exists, no patches)\n        2. Query patch for version \"1.1.0\" (no production, no patches)\n\n    Both should return None since no patch tags exist yet.\n\n    Validates:\n        - Proper None return for non-existent patch tags\n        - Patch tag querying for different version states\n        - Baseline establishment for patch workflow testing\n\n    Business Logic Tested:\n        - get_current_rc_patch() method with \"patch\" prerelease type\n        - Pattern matching for patch tags\n        - Handling of non-existent tag scenarios\n    \"\"\"\n    assert manager.get_current_rc_patch(\"1.0.0\", \"patch\") is None\n    assert manager.get_current_rc_patch(\"1.1.0\", \"patch\") is None\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_get_current_production_tag","title":"<code>test_get_current_production_tag()</code>","text":"<p>Test current production tag retrieval.</p> <p>This test verifies the VersionControlManager's ability to identify and return the current highest production version. This is essential for various operations including patch initialization and version management.</p> Test Scenario <ul> <li>Retrieve current production tag (should be \"1.0.1\" after patch)</li> </ul> Validates <ul> <li>Production tag identification</li> <li>Highest production version selection</li> <li>Patch version recognition as production</li> <li>Production tag querying functionality</li> </ul> Business Logic Tested <ul> <li>get_current_tag() method with production=True parameter</li> <li>Production tag pattern matching</li> <li>Semantic version sorting for production tags</li> <li>Production version history tracking</li> </ul> Workflow Context <p>After creating patch version 1.0.1, it should be recognized as the current production version, taking precedence over 1.0.0.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_get_current_production_tag():\n    \"\"\"Test current production tag retrieval.\n\n    This test verifies the VersionControlManager's ability to identify and return\n    the current highest production version. This is essential for various\n    operations including patch initialization and version management.\n\n    Test Scenario:\n        - Retrieve current production tag (should be \"1.0.1\" after patch)\n\n    Validates:\n        - Production tag identification\n        - Highest production version selection\n        - Patch version recognition as production\n        - Production tag querying functionality\n\n    Business Logic Tested:\n        - get_current_tag() method with production=True parameter\n        - Production tag pattern matching\n        - Semantic version sorting for production tags\n        - Production version history tracking\n\n    Workflow Context:\n        After creating patch version 1.0.1, it should be recognized as\n        the current production version, taking precedence over 1.0.0.\n    \"\"\"\n    assert manager.get_current_tag(production=True) == \"1.0.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_get_current_rc","title":"<code>test_get_current_rc()</code>","text":"<p>Test current release candidate retrieval for specific version.</p> <p>This test verifies the VersionControlManager's ability to find the current (highest) release candidate tag for a specific base version. This is essential for RC management and incrementing operations.</p> Test Scenario <ul> <li>Retrieve current RC for base version \"1.0.0\"</li> <li>Should return \"1.0.0-rc.1\" (the existing RC tag)</li> </ul> Validates <ul> <li>Base version to RC tag mapping</li> <li>Current RC identification for specific versions</li> <li>Proper pattern matching for RC tags</li> </ul> Business Logic Tested <ul> <li>get_current_rc_patch() method with RC prerelease type</li> <li>Version-specific tag pattern matching</li> <li>Highest RC tag identification within version family</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_get_current_rc():\n    \"\"\"Test current release candidate retrieval for specific version.\n\n    This test verifies the VersionControlManager's ability to find the current\n    (highest) release candidate tag for a specific base version. This\n    is essential for RC management and incrementing operations.\n\n    Test Scenario:\n        - Retrieve current RC for base version \"1.0.0\"\n        - Should return \"1.0.0-rc.1\" (the existing RC tag)\n\n    Validates:\n        - Base version to RC tag mapping\n        - Current RC identification for specific versions\n        - Proper pattern matching for RC tags\n\n    Business Logic Tested:\n        - get_current_rc_patch() method with RC prerelease type\n        - Version-specific tag pattern matching\n        - Highest RC tag identification within version family\n    \"\"\"\n    assert manager.get_current_rc_patch(\"1.0.0\") == \"1.0.0-rc.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_get_init_rc_tag","title":"<code>test_get_init_rc_tag()</code>","text":"<p>Test release candidate tag generation from development tags.</p> <p>This test verifies the static utility method that converts development tags into their corresponding initial release candidate tags. This is a crucial step in the development \u2192 RC \u2192 production workflow.</p> Test Scenario <ul> <li>Convert development tag \"1.0.0-dev.10\" to RC tag \"1.0.0-rc.1\"</li> </ul> Validates <ul> <li>Proper tag format conversion (dev.N \u2192 rc.1)</li> <li>Preservation of major.minor.patch version</li> <li>Static method functionality (no repository interaction)</li> <li>Semantic versioning rule compliance</li> </ul> Business Logic Tested <ul> <li>get_init_rc_tag() static method</li> <li>Development to RC tag transformation logic</li> <li>Version number parsing and reconstruction</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_get_init_rc_tag():\n    \"\"\"Test release candidate tag generation from development tags.\n\n    This test verifies the static utility method that converts development\n    tags into their corresponding initial release candidate tags. This is\n    a crucial step in the development \u2192 RC \u2192 production workflow.\n\n    Test Scenario:\n        - Convert development tag \"1.0.0-dev.10\" to RC tag \"1.0.0-rc.1\"\n\n    Validates:\n        - Proper tag format conversion (dev.N \u2192 rc.1)\n        - Preservation of major.minor.patch version\n        - Static method functionality (no repository interaction)\n        - Semantic versioning rule compliance\n\n    Business Logic Tested:\n        - get_init_rc_tag() static method\n        - Development to RC tag transformation logic\n        - Version number parsing and reconstruction\n    \"\"\"\n    assert manager.get_init_rc_tag(\"1.0.0-dev.10\") == \"1.0.0-rc.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_increment_dev_after_prod_release","title":"<code>test_increment_dev_after_prod_release()</code>","text":"<p>Test development tag incrementing after production release.</p> <p>This test verifies the VersionControlManager's ability to continue development work after a production release by automatically bumping to the next minor version for new development work. This ensures clear separation between released and unreleased code.</p> Test Scenario <ul> <li>Current dev tag is \"1.0.0-dev.10\" (same version as production \"1.0.0\")</li> <li>Incrementing should jump to \"1.1.0-dev.1\" (next minor version)</li> </ul> Validates <ul> <li>Automatic minor version bump when production version exists</li> <li>Prevention of dev tag confusion with released versions</li> <li>Proper version increment logic (1.0.x \u2192 1.1.0)</li> <li>Development workflow continuation after release</li> </ul> Business Logic Tested <ul> <li>increment_prerelease_tag() version bump logic</li> <li>Production version conflict detection</li> <li>Minor version incrementing rules</li> <li>Development tag reset to .1 after version bump</li> </ul> Workflow Context <p>This simulates the common scenario where development continues after a release, requiring a clear version separation between the released code and new development work.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_increment_dev_after_prod_release():\n    \"\"\"Test development tag incrementing after production release.\n\n    This test verifies the VersionControlManager's ability to continue development\n    work after a production release by automatically bumping to the next\n    minor version for new development work. This ensures clear separation\n    between released and unreleased code.\n\n    Test Scenario:\n        - Current dev tag is \"1.0.0-dev.10\" (same version as production \"1.0.0\")\n        - Incrementing should jump to \"1.1.0-dev.1\" (next minor version)\n\n    Validates:\n        - Automatic minor version bump when production version exists\n        - Prevention of dev tag confusion with released versions\n        - Proper version increment logic (1.0.x \u2192 1.1.0)\n        - Development workflow continuation after release\n\n    Business Logic Tested:\n        - increment_prerelease_tag() version bump logic\n        - Production version conflict detection\n        - Minor version incrementing rules\n        - Development tag reset to .1 after version bump\n\n    Workflow Context:\n        This simulates the common scenario where development continues\n        after a release, requiring a clear version separation between\n        the released code and new development work.\n    \"\"\"\n    assert manager.increment_prerelease_tag(manager.get_current_tag()) == \"1.1.0-dev.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_increment_patch","title":"<code>test_increment_patch()</code>","text":"<p>Test patch tag incrementing during hotfix development.</p> <p>This test verifies the VersionControlManager's ability to increment patch prerelease tags during hotfix development iterations. This allows multiple rounds of fixes and testing before the hotfix is released.</p> Test Scenario <ul> <li>Increment patch from \"1.0.0-patch.1\" to \"1.0.0-patch.2\"</li> </ul> Validates <ul> <li>Patch prerelease number incrementing (patch.1 \u2192 patch.2)</li> <li>Preservation of base production version (1.0.0)</li> <li>Hotfix iteration support</li> <li>Tag creation in repository</li> </ul> Business Logic Tested <ul> <li>increment_rc_patch() method with patch prerelease type</li> <li>Patch tag incrementing logic</li> <li>Hotfix development workflow support</li> <li>Prerelease number management for patches</li> </ul> Workflow Context <p>This simulates additional iterations in hotfix development, where multiple patch versions might be needed before the fix is ready for production deployment.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_increment_patch():\n    \"\"\"Test patch tag incrementing during hotfix development.\n\n    This test verifies the VersionControlManager's ability to increment patch\n    prerelease tags during hotfix development iterations. This allows\n    multiple rounds of fixes and testing before the hotfix is released.\n\n    Test Scenario:\n        - Increment patch from \"1.0.0-patch.1\" to \"1.0.0-patch.2\"\n\n    Validates:\n        - Patch prerelease number incrementing (patch.1 \u2192 patch.2)\n        - Preservation of base production version (1.0.0)\n        - Hotfix iteration support\n        - Tag creation in repository\n\n    Business Logic Tested:\n        - increment_rc_patch() method with patch prerelease type\n        - Patch tag incrementing logic\n        - Hotfix development workflow support\n        - Prerelease number management for patches\n\n    Workflow Context:\n        This simulates additional iterations in hotfix development,\n        where multiple patch versions might be needed before the\n        fix is ready for production deployment.\n    \"\"\"\n    assert manager.increment_rc_patch(\"1.0.0\", \"patch\") == \"1.0.0-patch.2\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_increment_patch_exception","title":"<code>test_increment_patch_exception()</code>","text":"<p>Test error handling for invalid patch increment attempts.</p> <p>This test verifies that the VersionControlManager enforces the business rule that patch tags can only be created for versions that have been released to production. This prevents patch creation for unreleased versions, maintaining version integrity.</p> Test Scenario <ul> <li>Attempt to create patch for version \"1.1.0\" (no production version)</li> <li>Should raise InvalidTagCreation exception</li> </ul> Validates <ul> <li>Business rule enforcement (patches require production version)</li> <li>Proper exception raising for invalid operations</li> <li>Production version prerequisite checking</li> <li>Error message clarity for debugging</li> </ul> Business Logic Tested <ul> <li>increment_rc_patch() validation with patch type</li> <li>InvalidTagCreation exception for rule violations</li> <li>Production version existence validation</li> <li>Patch creation prerequisites</li> </ul> Error Scenario <p>Documents the rule: \"No Production version available\" - patches can only be created for versions that have been officially released.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_increment_patch_exception():\n    \"\"\"Test error handling for invalid patch increment attempts.\n\n    This test verifies that the VersionControlManager enforces the business rule\n    that patch tags can only be created for versions that have been\n    released to production. This prevents patch creation for unreleased\n    versions, maintaining version integrity.\n\n    Test Scenario:\n        - Attempt to create patch for version \"1.1.0\" (no production version)\n        - Should raise InvalidTagCreation exception\n\n    Validates:\n        - Business rule enforcement (patches require production version)\n        - Proper exception raising for invalid operations\n        - Production version prerequisite checking\n        - Error message clarity for debugging\n\n    Business Logic Tested:\n        - increment_rc_patch() validation with patch type\n        - InvalidTagCreation exception for rule violations\n        - Production version existence validation\n        - Patch creation prerequisites\n\n    Error Scenario:\n        Documents the rule: \"No Production version available\" - patches\n        can only be created for versions that have been officially released.\n    \"\"\"\n    with pytest.raises(InvalidTagCreation):\n        manager.increment_rc_patch(\"1.1.0\", \"patch\")\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_increment_prerelease_tag","title":"<code>test_increment_prerelease_tag()</code>","text":"<p>Test prerelease tag incrementing functionality.</p> <p>This test verifies that the VersionControlManager can correctly increment the prerelease number of an existing development tag while maintaining the same major.minor.patch version numbers.</p> Test Scenario <ul> <li>Increment from existing tag \"1.0.0-dev.9\" to \"1.0.0-dev.10\"</li> <li>Verify the new tag becomes the current highest tag</li> </ul> Validates <ul> <li>Prerelease number incrementing (9 \u2192 10)</li> <li>Tag creation in repository</li> <li>Updated current tag retrieval</li> <li>Preservation of major.minor.patch version</li> </ul> Business Logic Tested <ul> <li>increment_prerelease_tag() with existing tag parameter</li> <li>Proper prerelease number parsing and incrementing</li> <li>Tag creation and registration in repository</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_increment_prerelease_tag():\n    \"\"\"Test prerelease tag incrementing functionality.\n\n    This test verifies that the VersionControlManager can correctly increment\n    the prerelease number of an existing development tag while maintaining\n    the same major.minor.patch version numbers.\n\n    Test Scenario:\n        - Increment from existing tag \"1.0.0-dev.9\" to \"1.0.0-dev.10\"\n        - Verify the new tag becomes the current highest tag\n\n    Validates:\n        - Prerelease number incrementing (9 \u2192 10)\n        - Tag creation in repository\n        - Updated current tag retrieval\n        - Preservation of major.minor.patch version\n\n    Business Logic Tested:\n        - increment_prerelease_tag() with existing tag parameter\n        - Proper prerelease number parsing and incrementing\n        - Tag creation and registration in repository\n    \"\"\"\n    assert manager.increment_prerelease_tag(\"1.0.0-dev.9\") == \"1.0.0-dev.10\"\n    assert manager.get_current_tag() == \"1.0.0-dev.10\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_increment_rc","title":"<code>test_increment_rc()</code>","text":"<p>Test release candidate tag incrementing.</p> <p>This test verifies the VersionControlManager's ability to create subsequent release candidate versions when additional RC iterations are needed during the testing and stabilization phase.</p> Test Scenario <ol> <li>Increment RC from \"1.0.0-rc.1\" to \"1.0.0-rc.2\"</li> <li>Verify new RC becomes the current RC for the version</li> </ol> Validates <ul> <li>RC prerelease number incrementing (rc.1 \u2192 rc.2)</li> <li>Preservation of base version (1.0.0)</li> <li>Tag creation in repository</li> <li>Updated current RC retrieval</li> </ul> Business Logic Tested <ul> <li>increment_rc_patch() method with RC prerelease type</li> <li>RC tag incrementing logic</li> <li>Current RC tag updating after increment</li> </ul> Workflow Context <p>This simulates the scenario where an RC needs additional iterations due to bugs found during testing, requiring RC.2, RC.3, etc.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_increment_rc():\n    \"\"\"Test release candidate tag incrementing.\n\n    This test verifies the VersionControlManager's ability to create subsequent\n    release candidate versions when additional RC iterations are needed\n    during the testing and stabilization phase.\n\n    Test Scenario:\n        1. Increment RC from \"1.0.0-rc.1\" to \"1.0.0-rc.2\"\n        2. Verify new RC becomes the current RC for the version\n\n    Validates:\n        - RC prerelease number incrementing (rc.1 \u2192 rc.2)\n        - Preservation of base version (1.0.0)\n        - Tag creation in repository\n        - Updated current RC retrieval\n\n    Business Logic Tested:\n        - increment_rc_patch() method with RC prerelease type\n        - RC tag incrementing logic\n        - Current RC tag updating after increment\n\n    Workflow Context:\n        This simulates the scenario where an RC needs additional iterations\n        due to bugs found during testing, requiring RC.2, RC.3, etc.\n    \"\"\"\n    assert manager.increment_rc_patch(\"1.0.0\") == \"1.0.0-rc.2\"\n    assert manager.get_current_rc_patch(\"1.0.0\") == \"1.0.0-rc.2\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_increment_rc_exception","title":"<code>test_increment_rc_exception()</code>","text":"<p>Test error handling for invalid RC increment attempts.</p> <p>This test verifies that the VersionControlManager properly enforces business rules by preventing RC tag creation when a production version already exists for the same version number. This prevents accidental regression or confusion in the versioning workflow.</p> Test Scenario <ul> <li>Attempt to increment RC for version \"1.0.0\" (production exists)</li> <li>Should raise InvalidTagCreation exception</li> </ul> Validates <ul> <li>Business rule enforcement (no RC after production)</li> <li>Proper exception raising and type</li> <li>Error message clarity and helpfulness</li> <li>Repository state validation before tag creation</li> </ul> Business Logic Tested <ul> <li>increment_rc_patch() validation logic</li> <li>InvalidTagCreation exception handling</li> <li>Production version existence checking</li> <li>Business rule compliance enforcement</li> </ul> Error Scenario <p>This test documents the rule: \"Cannot increment RC version for a version found in Production\" - once a version goes to production, no more RCs can be created for that version.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_increment_rc_exception():\n    \"\"\"Test error handling for invalid RC increment attempts.\n\n    This test verifies that the VersionControlManager properly enforces business\n    rules by preventing RC tag creation when a production version already\n    exists for the same version number. This prevents accidental regression\n    or confusion in the versioning workflow.\n\n    Test Scenario:\n        - Attempt to increment RC for version \"1.0.0\" (production exists)\n        - Should raise InvalidTagCreation exception\n\n    Validates:\n        - Business rule enforcement (no RC after production)\n        - Proper exception raising and type\n        - Error message clarity and helpfulness\n        - Repository state validation before tag creation\n\n    Business Logic Tested:\n        - increment_rc_patch() validation logic\n        - InvalidTagCreation exception handling\n        - Production version existence checking\n        - Business rule compliance enforcement\n\n    Error Scenario:\n        This test documents the rule: \"Cannot increment RC version for a\n        version found in Production\" - once a version goes to production,\n        no more RCs can be created for that version.\n    \"\"\"\n    with pytest.raises(InvalidTagCreation):\n        manager.increment_rc_patch(\"1.0.0\")\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_init_new_patch","title":"<code>test_init_new_patch()</code>","text":"<p>Test patch tag initialization for hotfix workflow.</p> <p>This test verifies the VersionControlManager's ability to initialize the patch workflow for production hotfixes. This creates the first patch prerelease tag based on the current production version, enabling hotfix development.</p> Test Scenario <ul> <li>Initialize patch from current production (should be \"1.0.0\")</li> <li>Should create \"1.0.0-patch.1\" for hotfix development</li> </ul> Validates <ul> <li>Patch initialization from production version</li> <li>Proper patch tag naming (version-patch.1)</li> <li>Hotfix workflow establishment</li> <li>Current production version detection</li> </ul> Business Logic Tested <ul> <li>init_new_patch() method</li> <li>Production to patch workflow transition</li> <li>Patch tag creation with proper commit reference</li> <li>Hotfix development setup</li> </ul> Workflow Context <p>This represents the beginning of a hotfix process where a critical bug in production needs to be addressed without waiting for the next major release cycle.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_init_new_patch():\n    \"\"\"Test patch tag initialization for hotfix workflow.\n\n    This test verifies the VersionControlManager's ability to initialize the\n    patch workflow for production hotfixes. This creates the first\n    patch prerelease tag based on the current production version,\n    enabling hotfix development.\n\n    Test Scenario:\n        - Initialize patch from current production (should be \"1.0.0\")\n        - Should create \"1.0.0-patch.1\" for hotfix development\n\n    Validates:\n        - Patch initialization from production version\n        - Proper patch tag naming (version-patch.1)\n        - Hotfix workflow establishment\n        - Current production version detection\n\n    Business Logic Tested:\n        - init_new_patch() method\n        - Production to patch workflow transition\n        - Patch tag creation with proper commit reference\n        - Hotfix development setup\n\n    Workflow Context:\n        This represents the beginning of a hotfix process where a\n        critical bug in production needs to be addressed without\n        waiting for the next major release cycle.\n    \"\"\"\n    assert manager.init_new_patch() == \"1.0.0-patch.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_init_new_rc","title":"<code>test_init_new_rc()</code>","text":"<p>Test release candidate initialization from current development tag.</p> <p>This test verifies the VersionControlManager's ability to create the first release candidate tag based on the highest existing development tag. This represents a key milestone in the development workflow where development is considered feature-complete and ready for testing.</p> Test Scenario <ol> <li>Initialize RC from current development tag (1.0.0-dev.10)</li> <li>Verify RC tag creation (1.0.0-rc.1)</li> <li>Confirm RC becomes current RC tag</li> </ol> Validates <ul> <li>RC initialization from development tag</li> <li>Proper RC tag naming (major.minor.patch-rc.1)</li> <li>Tag creation in repository with appropriate commit reference</li> <li>Current RC tag retrieval functionality</li> </ul> Business Logic Tested <ul> <li>init_new_rc() method with development prerelease parameter</li> <li>Development to RC workflow transition</li> <li>Tag creation with commit referencing</li> <li>RC tag identification and retrieval</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_init_new_rc():\n    \"\"\"Test release candidate initialization from current development tag.\n\n    This test verifies the VersionControlManager's ability to create the first\n    release candidate tag based on the highest existing development tag.\n    This represents a key milestone in the development workflow where\n    development is considered feature-complete and ready for testing.\n\n    Test Scenario:\n        1. Initialize RC from current development tag (1.0.0-dev.10)\n        2. Verify RC tag creation (1.0.0-rc.1)\n        3. Confirm RC becomes current RC tag\n\n    Validates:\n        - RC initialization from development tag\n        - Proper RC tag naming (major.minor.patch-rc.1)\n        - Tag creation in repository with appropriate commit reference\n        - Current RC tag retrieval functionality\n\n    Business Logic Tested:\n        - init_new_rc() method with development prerelease parameter\n        - Development to RC workflow transition\n        - Tag creation with commit referencing\n        - RC tag identification and retrieval\n    \"\"\"\n    assert manager.init_new_rc(\"dev\") == \"1.0.0-rc.1\"\n    assert manager.get_current_tag(\"rc\") == \"1.0.0-rc.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_invalid_tag_format_handling","title":"<code>test_invalid_tag_format_handling()</code>","text":"<p>Test handling of invalid tag formats and edge cases.</p> <p>This test validates that the VersionControlManager properly handles and rejects invalid tag formats, maintaining system integrity and providing clear error messages.</p> Test Scenarios <ol> <li>Invalid prerelease tag formats</li> <li>Invalid production tag formats</li> <li>Malformed version numbers</li> <li>Edge case version patterns</li> </ol> Validates <ul> <li>Proper ValueError raising for invalid formats</li> <li>Input validation before tag operations</li> <li>Error message clarity and helpfulness</li> <li>System protection against malformed inputs</li> </ul> Business Logic Tested <ul> <li>Tag format validation across all methods</li> <li>ValueError exception handling</li> <li>Input sanitization and validation</li> <li>Format compliance enforcement</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_invalid_tag_format_handling():\n    \"\"\"Test handling of invalid tag formats and edge cases.\n\n    This test validates that the VersionControlManager properly handles and\n    rejects invalid tag formats, maintaining system integrity and\n    providing clear error messages.\n\n    Test Scenarios:\n        1. Invalid prerelease tag formats\n        2. Invalid production tag formats\n        3. Malformed version numbers\n        4. Edge case version patterns\n\n    Validates:\n        - Proper ValueError raising for invalid formats\n        - Input validation before tag operations\n        - Error message clarity and helpfulness\n        - System protection against malformed inputs\n\n    Business Logic Tested:\n        - Tag format validation across all methods\n        - ValueError exception handling\n        - Input sanitization and validation\n        - Format compliance enforcement\n    \"\"\"\n    # Test invalid formats for get_init_rc_tag\n    invalid_formats = [\n        \"1.0.0\",  # Missing prerelease\n        \"1.0-dev.1\",  # Missing patch version\n        \"1.0.0-dev\",  # Missing prerelease number\n        \"invalid-tag\",  # Non-semantic format\n        \"\",  # Empty string\n        \"1.0.0-dev.a\",  # Non-numeric prerelease\n    ]\n\n    for invalid_format in invalid_formats:\n        with pytest.raises(ValueError):\n            manager.get_init_rc_tag(invalid_format)\n\n    # Test invalid formats for increment_prerelease_tag\n    for invalid_format in invalid_formats:\n        if invalid_format:  # Skip empty string for this test\n            with pytest.raises(ValueError):\n                manager.increment_prerelease_tag(invalid_format)\n\n    # Test invalid formats for create_prod_tag\n    invalid_prod_formats = [\n        \"1.0.0\",  # Already production format\n        \"1.0.0-dev.1\",  # Development format (not RC/patch)\n        \"invalid-tag\",  # Non-semantic format\n        \"1.0.0-invalid.1\",  # Unknown prerelease type\n    ]\n\n    for invalid_format in invalid_prod_formats:\n        with pytest.raises(ValueError):\n            manager.create_prod_tag(invalid_format)\n\n    # Cleanup: Delete test repository after all tests complete\n    if os.path.isdir(\"test_dir\"):\n        shutil.rmtree(\"test_dir\")\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_major_bump","title":"<code>test_major_bump()</code>","text":"<p>Test complete major version bump workflow.</p> <p>This comprehensive test verifies the VersionControlManager's ability to handle a complete major version bump scenario, simulating a development cycle that includes breaking changes requiring a major version increment.</p> Test Workflow <ol> <li>Start with current dev tag \"1.1.0-dev.1\"</li> <li>Increment to \"1.1.0-dev.2\" (normal development)</li> <li>Create RC \"1.1.0-rc.1\" and promote to production \"1.1.0\"</li> <li>Perform major bump to \"2.0.0-dev.1\" (breaking changes)</li> <li>Verify new major version becomes current</li> </ol> Validates <ul> <li>Complete development cycle (dev \u2192 RC \u2192 production)</li> <li>Major version bumping logic (1.x.x \u2192 2.0.0)</li> <li>Version reset behavior (minor and patch reset to 0)</li> <li>Development tag reset to .1 after major bump</li> <li>Production version progression (1.0.1 \u2192 1.1.0 \u2192 current)</li> </ul> Business Logic Tested <ul> <li>increment_prerelease_tag() normal and major bump modes</li> <li>init_new_rc() and create_prod_tag() workflow</li> <li>Major version bump with major_bump=True parameter</li> <li>Version number reset rules for major bumps</li> <li>Current tag tracking across version families</li> </ul> Workflow Context <p>This simulates a complete development cycle where significant breaking changes necessitate a major version increment, following semantic versioning principles where major bumps indicate backward-incompatible changes.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_major_bump():\n    \"\"\"Test complete major version bump workflow.\n\n    This comprehensive test verifies the VersionControlManager's ability to handle\n    a complete major version bump scenario, simulating a development cycle\n    that includes breaking changes requiring a major version increment.\n\n    Test Workflow:\n        1. Start with current dev tag \"1.1.0-dev.1\"\n        2. Increment to \"1.1.0-dev.2\" (normal development)\n        3. Create RC \"1.1.0-rc.1\" and promote to production \"1.1.0\"\n        4. Perform major bump to \"2.0.0-dev.1\" (breaking changes)\n        5. Verify new major version becomes current\n\n    Validates:\n        - Complete development cycle (dev \u2192 RC \u2192 production)\n        - Major version bumping logic (1.x.x \u2192 2.0.0)\n        - Version reset behavior (minor and patch reset to 0)\n        - Development tag reset to .1 after major bump\n        - Production version progression (1.0.1 \u2192 1.1.0 \u2192 current)\n\n    Business Logic Tested:\n        - increment_prerelease_tag() normal and major bump modes\n        - init_new_rc() and create_prod_tag() workflow\n        - Major version bump with major_bump=True parameter\n        - Version number reset rules for major bumps\n        - Current tag tracking across version families\n\n    Workflow Context:\n        This simulates a complete development cycle where significant\n        breaking changes necessitate a major version increment, following\n        semantic versioning principles where major bumps indicate\n        backward-incompatible changes.\n    \"\"\"\n    assert manager.get_current_tag() == \"1.1.0-dev.1\"\n    assert manager.increment_prerelease_tag(tag=\"1.1.0-dev.1\") == \"1.1.0-dev.2\"\n    assert manager.init_new_rc() == \"1.1.0-rc.1\"\n    assert manager.create_prod_tag(\"1.1.0-rc.1\") == \"1.1.0\"\n    assert manager.get_current_tag(production=True) == \"1.1.0\"\n    assert manager.increment_prerelease_tag(\"1.1.0-dev.2\", major_bump=True) == \"2.0.0-dev.1\"\n    assert manager.get_current_tag() == \"2.0.0-dev.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_multiple_rc_iterations","title":"<code>test_multiple_rc_iterations()</code>","text":"<p>Test multiple release candidate iterations before production.</p> <p>This test simulates a realistic scenario where multiple RC versions are needed due to bugs found during testing. It validates the complete RC iteration workflow and proper version incrementing.</p> Test Workflow <ol> <li>Create multiple RC iterations (rc.1 \u2192 rc.2 \u2192 rc.3)</li> <li>Verify each increment is properly tracked</li> <li>Promote final RC to production</li> <li>Verify production version is correct</li> </ol> Validates <ul> <li>Multiple RC increments within same version</li> <li>RC version tracking and retrieval</li> <li>Final RC promotion to production</li> <li>Version consistency throughout process</li> </ul> Business Logic Tested <ul> <li>increment_rc_patch() multiple iterations</li> <li>get_current_rc_patch() after each increment</li> <li>create_prod_tag() from any RC iteration</li> <li>RC workflow resilience with multiple iterations</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_multiple_rc_iterations():\n    \"\"\"Test multiple release candidate iterations before production.\n\n    This test simulates a realistic scenario where multiple RC versions\n    are needed due to bugs found during testing. It validates the complete\n    RC iteration workflow and proper version incrementing.\n\n    Test Workflow:\n        1. Create multiple RC iterations (rc.1 \u2192 rc.2 \u2192 rc.3)\n        2. Verify each increment is properly tracked\n        3. Promote final RC to production\n        4. Verify production version is correct\n\n    Validates:\n        - Multiple RC increments within same version\n        - RC version tracking and retrieval\n        - Final RC promotion to production\n        - Version consistency throughout process\n\n    Business Logic Tested:\n        - increment_rc_patch() multiple iterations\n        - get_current_rc_patch() after each increment\n        - create_prod_tag() from any RC iteration\n        - RC workflow resilience with multiple iterations\n    \"\"\"\n    # Start fresh RC workflow from current dev\n    assert manager.init_new_rc() == \"2.0.0-rc.1\"\n\n    # Multiple RC iterations (simulating bug fixes during testing)\n    assert manager.increment_rc_patch(\"2.0.0\") == \"2.0.0-rc.2\"\n    assert manager.get_current_rc_patch(\"2.0.0\") == \"2.0.0-rc.2\"\n\n    assert manager.increment_rc_patch(\"2.0.0\") == \"2.0.0-rc.3\"\n    assert manager.get_current_rc_patch(\"2.0.0\") == \"2.0.0-rc.3\"\n\n    # Finally promote to production\n    assert manager.create_prod_tag(\"2.0.0-rc.3\") == \"2.0.0\"\n    assert manager.get_current_tag(production=True) == \"2.0.0\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_parallel_development_after_release","title":"<code>test_parallel_development_after_release()</code>","text":"<p>Test parallel development workflow after production release.</p> <p>This test simulates a realistic scenario where development continues in parallel with production releases and hotfixes. It validates that development can proceed independently while production versions are being patched.</p> Test Workflow <ol> <li>Continue development after 2.0.0 release (should bump to 2.1.0-dev.1)</li> <li>Create multiple development iterations</li> <li>While dev continues, ensure patch workflow still works</li> <li>Create RC from latest development</li> <li>Validate version separation and independence</li> </ol> Validates <ul> <li>Development continuation after production release</li> <li>Proper minor version bump for new development</li> <li>Independence of dev and patch workflows</li> <li>Version family separation (2.0.x patches vs 2.1.x development)</li> <li>Multiple concurrent version tracks</li> </ul> Business Logic Tested <ul> <li>increment_prerelease_tag() with automatic version bump detection</li> <li>Parallel workflow support (dev vs patch)</li> <li>Version family isolation</li> <li>Current tag tracking across different version families</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_parallel_development_after_release():\n    \"\"\"Test parallel development workflow after production release.\n\n    This test simulates a realistic scenario where development continues\n    in parallel with production releases and hotfixes. It validates that\n    development can proceed independently while production versions are\n    being patched.\n\n    Test Workflow:\n        1. Continue development after 2.0.0 release (should bump to 2.1.0-dev.1)\n        2. Create multiple development iterations\n        3. While dev continues, ensure patch workflow still works\n        4. Create RC from latest development\n        5. Validate version separation and independence\n\n    Validates:\n        - Development continuation after production release\n        - Proper minor version bump for new development\n        - Independence of dev and patch workflows\n        - Version family separation (2.0.x patches vs 2.1.x development)\n        - Multiple concurrent version tracks\n\n    Business Logic Tested:\n        - increment_prerelease_tag() with automatic version bump detection\n        - Parallel workflow support (dev vs patch)\n        - Version family isolation\n        - Current tag tracking across different version families\n    \"\"\"\n    # Development continues after 2.0.0 release\n    # Should automatically bump to 2.1.0 since 2.0.0 is in production\n    current_dev = manager.get_current_tag()  # Should be 2.0.0-dev.1\n    assert manager.increment_prerelease_tag(current_dev) == \"2.1.0-dev.1\"\n\n    # Continue development iterations\n    assert manager.increment_prerelease_tag(\"2.1.0-dev.1\") == \"2.1.0-dev.2\"\n    assert manager.increment_prerelease_tag(\"2.1.0-dev.2\") == \"2.1.0-dev.3\"\n    assert manager.get_current_tag() == \"2.1.0-dev.3\"\n\n    # Meanwhile, patch workflow should still work for production versions\n    # (This validates parallel development and patch workflows)\n    assert manager.get_current_tag(production=True) == \"2.0.2\"\n\n    # Create RC from current development\n    assert manager.init_new_rc() == \"2.1.0-rc.1\"\n    assert manager.get_current_tag(\"rc\") == \"2.1.0-rc.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_patch_workflow_comprehensive","title":"<code>test_patch_workflow_comprehensive()</code>","text":"<p>Test comprehensive patch workflow with multiple iterations.</p> <p>This test validates the complete patch/hotfix workflow including multiple patch iterations, proper version incrementing, and integration with the existing production version history.</p> Test Workflow <ol> <li>Create initial patch from production 2.0.0</li> <li>Increment patch multiple times (simulating hotfix development)</li> <li>Promote patch to production (creates 2.0.1)</li> <li>Create another patch series for 2.0.1</li> <li>Validate version progression and current version tracking</li> </ol> Validates <ul> <li>Patch initialization from any production version</li> <li>Multiple patch increments within same base version</li> <li>Patch promotion creating proper production increment</li> <li>Ability to patch the patched version</li> <li>Production version progression (2.0.0 \u2192 2.0.1 \u2192 2.0.2)</li> </ul> Business Logic Tested <ul> <li>init_new_patch() from latest production</li> <li>increment_rc_patch() with patch type multiple times</li> <li>create_prod_tag() from patch creating incremented production</li> <li>Patch workflow on previously patched versions</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_patch_workflow_comprehensive():\n    \"\"\"Test comprehensive patch workflow with multiple iterations.\n\n    This test validates the complete patch/hotfix workflow including\n    multiple patch iterations, proper version incrementing, and\n    integration with the existing production version history.\n\n    Test Workflow:\n        1. Create initial patch from production 2.0.0\n        2. Increment patch multiple times (simulating hotfix development)\n        3. Promote patch to production (creates 2.0.1)\n        4. Create another patch series for 2.0.1\n        5. Validate version progression and current version tracking\n\n    Validates:\n        - Patch initialization from any production version\n        - Multiple patch increments within same base version\n        - Patch promotion creating proper production increment\n        - Ability to patch the patched version\n        - Production version progression (2.0.0 \u2192 2.0.1 \u2192 2.0.2)\n\n    Business Logic Tested:\n        - init_new_patch() from latest production\n        - increment_rc_patch() with patch type multiple times\n        - create_prod_tag() from patch creating incremented production\n        - Patch workflow on previously patched versions\n    \"\"\"\n    # Initialize patch for current production (2.0.0)\n    assert manager.init_new_patch() == \"2.0.0-patch.1\"\n\n    # Multiple patch iterations (simulating hotfix development)\n    assert manager.increment_rc_patch(\"2.0.0\", \"patch\") == \"2.0.0-patch.2\"\n    assert manager.increment_rc_patch(\"2.0.0\", \"patch\") == \"2.0.0-patch.3\"\n    assert manager.get_current_rc_patch(\"2.0.0\", \"patch\") == \"2.0.0-patch.3\"\n\n    # Promote patch to production (2.0.0 \u2192 2.0.1)\n    assert manager.create_prod_tag(\"2.0.0-patch.3\") == \"2.0.1\"\n    assert manager.get_current_tag(production=True) == \"2.0.1\"\n\n    # Create another patch series for the newly created production version\n    assert manager.init_new_patch() == \"2.0.1-patch.1\"\n    assert manager.increment_rc_patch(\"2.0.1\", \"patch\") == \"2.0.1-patch.2\"\n\n    # Promote second patch series\n    assert manager.create_prod_tag(\"2.0.1-patch.2\") == \"2.0.2\"\n    assert manager.get_current_tag(production=True) == \"2.0.2\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_prod_release","title":"<code>test_prod_release()</code>","text":"<p>Test production tag creation from release candidate.</p> <p>This test verifies the final step in the development workflow: promoting a tested and approved release candidate to a production version. This represents the official release of the software version.</p> Test Scenario <ul> <li>Promote RC tag \"1.0.0-rc.2\" to production tag \"1.0.0\"</li> </ul> Validates <ul> <li>RC to production tag conversion</li> <li>Removal of prerelease suffix (-rc.2 \u2192 \"\")</li> <li>Tag creation with proper commit reference</li> <li>Production tag format compliance</li> </ul> Business Logic Tested <ul> <li>create_prod_tag() method with RC tag parameter</li> <li>RC to production workflow transition</li> <li>Production tag naming rules</li> <li>Commit reference preservation during promotion</li> </ul> Workflow Context <p>This represents the culmination of the development cycle where a thoroughly tested RC is deemed ready for production deployment.</p> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_prod_release():\n    \"\"\"Test production tag creation from release candidate.\n\n    This test verifies the final step in the development workflow: promoting\n    a tested and approved release candidate to a production version. This\n    represents the official release of the software version.\n\n    Test Scenario:\n        - Promote RC tag \"1.0.0-rc.2\" to production tag \"1.0.0\"\n\n    Validates:\n        - RC to production tag conversion\n        - Removal of prerelease suffix (-rc.2 \u2192 \"\")\n        - Tag creation with proper commit reference\n        - Production tag format compliance\n\n    Business Logic Tested:\n        - create_prod_tag() method with RC tag parameter\n        - RC to production workflow transition\n        - Production tag naming rules\n        - Commit reference preservation during promotion\n\n    Workflow Context:\n        This represents the culmination of the development cycle where\n        a thoroughly tested RC is deemed ready for production deployment.\n    \"\"\"\n    assert manager.create_prod_tag(\"1.0.0-rc.2\") == \"1.0.0\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_repository_state_integrity","title":"<code>test_repository_state_integrity()</code>","text":"<p>Test repository state integrity throughout complex operations.</p> <p>This test validates that the VersionControlManager maintains repository integrity and consistency throughout complex operation sequences. It ensures no orphaned tags or inconsistent states are created.</p> Test Scenarios <ol> <li>Verify all created tags exist in repository</li> <li>Validate tag-commit relationships</li> <li>Check version history consistency</li> <li>Ensure no duplicate or conflicting tags</li> </ol> Validates <ul> <li>Repository tag integrity</li> <li>Consistent tag-commit relationships</li> <li>Version history accuracy</li> <li>No duplicate or orphaned tags</li> </ul> Business Logic Tested <ul> <li>find_tag() accuracy for all created tags</li> <li>Repository state consistency</li> <li>Tag creation integrity</li> <li>Version tracking accuracy</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_repository_state_integrity():\n    \"\"\"Test repository state integrity throughout complex operations.\n\n    This test validates that the VersionControlManager maintains repository\n    integrity and consistency throughout complex operation sequences.\n    It ensures no orphaned tags or inconsistent states are created.\n\n    Test Scenarios:\n        1. Verify all created tags exist in repository\n        2. Validate tag-commit relationships\n        3. Check version history consistency\n        4. Ensure no duplicate or conflicting tags\n\n    Validates:\n        - Repository tag integrity\n        - Consistent tag-commit relationships\n        - Version history accuracy\n        - No duplicate or orphaned tags\n\n    Business Logic Tested:\n        - find_tag() accuracy for all created tags\n        - Repository state consistency\n        - Tag creation integrity\n        - Version tracking accuracy\n    \"\"\"\n    # Test a comprehensive list of tags that should exist\n    expected_tags = [\n        \"0.1.0-dev.1\",  # Initial tag\n        \"1.0.0-dev.9\",  # From create_tags()\n        \"1.0.0-dev.10\",  # Incremented\n        \"1.0.0-rc.1\",  # RC initialized\n        \"1.0.0-rc.2\",  # RC incremented\n        \"1.0.0\",  # Production from RC\n        \"1.0.0-patch.1\",  # Patch initialized\n        \"1.0.0-patch.2\",  # Patch incremented\n        \"1.0.1\",  # Production from patch\n        \"1.1.0-dev.1\",  # Dev after production\n        \"1.1.0-dev.2\",  # Dev incremented\n        \"1.1.0-rc.1\",  # RC from dev\n        \"1.1.0\",  # Production from RC\n        \"2.0.0-dev.1\",  # Major bump\n        \"2.0.0-rc.1\",  # RC from major\n        \"2.0.0-rc.2\",  # RC incremented\n        \"2.0.0-rc.3\",  # RC incremented\n        \"2.0.0\",  # Production from RC\n        \"2.0.0-patch.1\",  # Patch initialized\n        \"2.0.0-patch.2\",  # Patch incremented\n        \"2.0.0-patch.3\",  # Patch incremented\n        \"2.0.1\",  # Production from patch\n        \"2.0.1-patch.1\",  # Second patch series\n        \"2.0.1-patch.2\",  # Second patch incremented\n        \"2.0.2\",  # Production from second patch\n        \"2.1.0-dev.1\",  # New dev cycle\n        \"2.1.0-dev.2\",  # Dev incremented\n        \"2.1.0-dev.3\",  # Dev incremented\n        \"2.1.0-rc.1\",  # RC from dev\n        \"2.1.0\",  # Production from RC\n        \"2.2.0-dev.1\",  # Minor bump dev\n        \"2.2.0-dev.2\",  # Dev incremented\n        \"3.0.0-dev.1\",  # Major bump\n        \"3.0.0-rc.1\",  # RC from major\n        \"3.0.0\",  # Final production\n    ]\n\n    # Verify all expected tags exist\n    for tag in expected_tags:\n        assert manager.find_tag(tag), f\"Expected tag {tag} not found in repository\"\n\n    # Verify current state accuracy\n    assert manager.get_current_tag() == \"3.0.0-dev.1\"  # Latest dev (if any remaining)\n    assert manager.get_current_tag(production=True) == \"3.0.0\"  # Latest production\n    assert manager.get_current_tag(\"rc\") is None or manager.get_current_tag(\"rc\") == \"3.0.0-rc.1\"\n</code></pre>"},{"location":"tests/#tests.test_vcm.test_version_conflict_prevention","title":"<code>test_version_conflict_prevention()</code>","text":"<p>Test version conflict prevention and validation rules.</p> <p>This test validates all the business rules that prevent invalid version states and conflicts in the semantic versioning workflow. It ensures proper error handling and validation.</p> Test Scenarios <ol> <li>Try to create RC when production already exists</li> <li>Try to create patch when no production exists</li> <li>Try to increment patch when higher patch exists in production</li> <li>Validate proper exception messages and types</li> </ol> Validates <ul> <li>Business rule enforcement prevents invalid states</li> <li>Proper exception types (InvalidTagCreation)</li> <li>Clear error messages for debugging</li> <li>Version state validation before tag creation</li> </ul> Business Logic Tested <ul> <li>increment_rc_patch() validation rules</li> <li>InvalidTagCreation exception handling</li> <li>Production version conflict detection</li> <li>Patch prerequisite validation</li> </ul> Source code in <code>tests/test_vcm.py</code> <pre><code>def test_version_conflict_prevention():\n    \"\"\"Test version conflict prevention and validation rules.\n\n    This test validates all the business rules that prevent invalid\n    version states and conflicts in the semantic versioning workflow.\n    It ensures proper error handling and validation.\n\n    Test Scenarios:\n        1. Try to create RC when production already exists\n        2. Try to create patch when no production exists\n        3. Try to increment patch when higher patch exists in production\n        4. Validate proper exception messages and types\n\n    Validates:\n        - Business rule enforcement prevents invalid states\n        - Proper exception types (InvalidTagCreation)\n        - Clear error messages for debugging\n        - Version state validation before tag creation\n\n    Business Logic Tested:\n        - increment_rc_patch() validation rules\n        - InvalidTagCreation exception handling\n        - Production version conflict detection\n        - Patch prerequisite validation\n    \"\"\"\n    # Rule 1: Cannot create RC when production version exists\n    with pytest.raises(InvalidTagCreation) as exc_info:\n        manager.increment_rc_patch(\"2.0.0\")  # Production 2.0.0 exists\n    assert \"Production version available\" in str(exc_info.value)\n\n    # Rule 2: Cannot create patch when no production version exists\n    with pytest.raises(InvalidTagCreation) as exc_info:\n        manager.increment_rc_patch(\"3.0.0\", \"patch\")  # No production 3.0.0\n    assert \"Production version not available\" in str(exc_info.value)\n\n    # Rule 3: Cannot increment patch when higher patch exists in production\n    # First, let's create a scenario where this would apply\n    empty_commit()\n    create_tag(\"2.0.3\")  # Simulate higher patch in production\n\n    with pytest.raises(InvalidTagCreation) as exc_info:\n        manager.increment_rc_patch(\"2.0.2\", \"patch\")  # 2.0.3 already exists\n    assert \"Patch found in Production\" in str(exc_info.value)\n</code></pre>"}]}